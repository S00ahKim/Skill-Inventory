# 템플릿 메소드 패턴
> 알고리즘을 캡슐화해서 서브클래스에서 일부 단계의 구현을 처리하게 하자
- 추상 클래스의 어떤 메소드가 어떤 알고리즘에 대한 **템플릿(틀)** 역할을 함
- 템플릿 내에서 알고리즘의 각 **단계**는 메소드로 표현됨
- 각 단계의 메소드 일부는 슈퍼클래스, 일부는 서브클래스에서 구현됨
- 구분
    * 공통 로직은 구상 메소드
    * 서브클래스에서 구현되어야 하는 것은 추상 메소드
    * 선택적인 것은 hook 메소드


## 예시
```java
// 추상 클래스로 선언되므로 실제 연산을 구현해주는 서브 클래스를 만들어야 함
abstract class 방송 {
  // 서브 클래스에서 알고리즘을 맘대로 바꾸지 않게 하려면 final로 선언함
  final void 템플릿메소드() {
    // 각 단계를 순서대로 >>메소드로 정의<<
    방송자검증();
    방송세팅();
    if (지금시작()) {
      송출시작();
    }
  }

  // 공통 로직은 <구상 메소드>로 만들어도 됨. 변경을 허용하지 않을 경우 final을 붙일 것.
  void 방송자검증() {
    권한있는지 검사;
  }

  // 실질적 로직이 없는 구상 메소드는 hook이라고 하며, 오버라이드해서 적절한 로직을 부여하면 됨.
  // 이 단계가 필수적이지 않고, 선택적일 경우 <hook>으로 제공.
  boolean 지금시작() {
    return true;
  }

  // 구현해야 하는 메소드는 <추상 메소드>로 남긴다
  abstract void 방송세팅();
  abstract void 송출시작();
}

public class 앱방송 extends 방송 {
  public void 방송세팅() {
    세팅합니다;
  }

  // 재정의한 예
  public boolean 지금시작() {
    if (시작하라고_하던가요()) {
      return true;
    } else {
      return false;
    }
  }

  public boolean 시작하라고_하던가요(String 대답) {
    if (대답.startsWith("y")) {
      return true;
    } else {
      return false;
    }
  }

  public void 송출시작() {
    송출합니다;
  }
}
```


## 어떻게?
- 코드의 중복 발견 -> 디자인을 고쳐야 하지 않을까 생각하기
- 공통 부분을 추상화해서 베이스 클래스 만들기
- 중복된 코드는 일반화하기
- 일부 단계는 서브클래스에 의존하게 하기


## 장점
1. 확장에 열려 있음
    * 공통된 부분을 뺀 거라서 수정도 공통 지점에만 하면 되니까
    * 각 단계에서 다른 구조를 쓰면서도 알고리즘의 큰 구조는 유지할 수 있어서
2. 코드 재사용에 도움이 됨
    * 알고리즘이 거의 똑같고 한 줄만 다르다면 아주 효율적!
    * 코드 중복이 거의 없게 돕는 패턴
3. 코드를 읽는 데에 도움이 됨 (상위 클래스를 보면 하위 구현들을 쉽게 이해할 수 있음)
4. 프레임워크를 만드는 데 훌륭한 디자인 도구 (작업 처리는 제어, 각 단계는 사용자가 지정 가능)


## 헐리우드 원칙
> 고->저 : 먼저 연락하지 마세요. 저희가 연락드리겠습니다. <br/>
> (cf. 할리우드에서 배우들과 연락하는 것과 비슷해서 붙은 이름)
- 무엇?
    * 저수준 컴포넌트에서는 고수준 컴포넌트를 호출할 수 없다
    * 저수준 컴포넌트를 어떻게 쓸지는 고수준 컴포넌트에서만 결정할 수 있다
- 장점?
    * 의존성 부패(고수준 컴포넌트->저수준 컴포넌트->고->저->...; 순환 의존성)를 방지할 수 있다
    * 의존성 부패가 있는 시스템은 시스템 디자인이 어떻게 됐는지 파악이 어렵다
- 타 패턴과의 유사점?
    * 템플릿 메소드 패턴 `추상 클래스 -> 서브 클래스 : 먼저 연락하지 마세요. 저희가 연락드리겠습니다.`
    * 팩토리 메소드 패턴
    * 옵저버 패턴
- 의존성 뒤집기(역전) 원칙과의 관계?
  * 의존성 뒤집기 원칙 = 될 수 있으면 구상 클래스 사용을 줄이고 대신 추상화된 것을 사용하라
  * 둘 다 객체 분리라는 목푤르 공유하지만, 의존성 뒤집기 원칙이 더 일반적이다.


## 자바API에서의 예시
### Arrays의 sort()
```java
// 모든 배열에서 이걸 쓰려고 디자인했다. 이 알고리즘은 수정할 수 없다.
public static void sort(Object[] a) {
  복사본 = 배열의 복사본을 만듦;
  mergeSort(복사본, a, 0, a.length, 0);
}

// 템플릿 메소드
private static void mergeSort(Object[] src[], Object dest[], int low, int high, int off) {
  for (int i = low; i<high; i++) {
    for (int j=i; j>low &&
      // 템플릿 메소드를 완성하려면, 객체의 대소관계를 판단한 결과를 리턴하는 compareTo()를 구현해야 함.
      ((Comparable)dest[j-1]).compareTo((Comparable)dest[j])>0; j--)
      // ㄴ compareTo를 구현했는지 알아야 했기 때문에 Comparable 인터페이스가 도입됨
      //    이 메소드에만 사용자의 의도가 반영될 수 있음. sort()는 결과적으로 compareTo()에 의존.
    {
      swap(dest, j, j-1); // Arrays 클래스에 정의된 구상 메소드
    }
  }
  return;
}

// 정렬하려는, Arrays 안에 들어가있는 '오리'객체 예시
public class Duck implements Comparable {
  String name;
  int weight;

  public Duck(String name, int weight) {
    this.name = name;
    this.weight = weight;
  }

  // compareTo의 구현
  public int compareTo(Object object) {
    Duck otherDuck = (Duck)object;

    if (this.weight < otherDuck.weight) {
      return -1;
    } else if (this.weight == otherDuck.weight) {
      return 0;
    } else {
      return 1;
    }
  }
}

// 이제 아래와 같은 코드를 돌릴 수 있다.
Duck[] ducks = {...}
Arrays.sort(ducks);
```
* 완전히 템플릿 메소드 패턴에 100% 일치한다고는 할 수 없으나, 상당 부분 유사한 방식.
* Arrays의 sort 메소드를 만들 때에는 `1. 자바 배열의 서브클래스 생성 불가` `2. 모든 배열에서 정렬 기능 사용 가능`해야 한다는 제약이 있었음. 그래서 Arrays의 서브클래스를 만들지 않고도 유연한 정렬 메소드를 만들 수 있었음.
* 이처럼 실전에서는 교과서적인 방식으로 쓰이지 않는 경우가 있다.
### 또 다른 예? 
* JFrame: hook 메소드인 print()를 오버라이드해서 화면 특정 영역에 어떤 내용을 표시 가능
* Applet: 다양한 hook 메소드를 사용해 작업을 처리할 수 있음
* InputStream의 read()


## [스트래티지 패턴](./StrategyPattern.md)과의 비교
- 공통점: 알고리즘을 캡슐화한다.
- 차이점: `상속`(템플릿 메소드) 대 `구성`(스트래티지)
    * 스트래티지 패턴에서는 알고리즘에 서브 클래스가 개입할 여지가 없다
    * 템플릿 메소드 패턴의 상위 클래스는 **추상 클래스**이긴 하지만, 일부는 서브 클래스에 의존하므로 의존성이 조금 크다