# 팩토리 패턴

- new는 구상 객체이며, 변화에 취약하다 (!)
- 어떤 객체를 생성하는 작업을 한 클래스에 캡슐화해서 구현을 변경해야 하는 경우 이 클래스에만 수정을 가하면 됨
- 간단한 팩토리를 정적 메소드로 정의하는 기법은 static factory 기법으로, 생성을 위해 인스턴스를 만들지 않아도 되지만, 서브클래스를 만들 수 없다

## 팩토리 메소드 패턴 
- 객체 생성을 위한 인터페이스를 정의하되 무슨 객체를 생성하는지 구체적인 작업은 서브클래스에 캡슐화함
- 구성
    * 추상 Creator 클래스 <- 구상 Creator 클래스
    * 추상 Product 클래스 <- 구상 Product 클래스
    * 구상 Creator 클래스는 자기 성격에 맞는 Product를 생산한다
    * Creator 클래스는 자기가 무엇을 생산(Product)하는지 전혀 모른다
- 간단한 팩토리는 일회용 처방이라면, 팩토리 메소드 패턴은 어떤 구현을 사용할지 서브클래스에서 결정하는 프레임워크를 만들 수 있음
- 파라미터를 문자열 타입으로 한 팩토리의 경우 타입 안전성 문제가 있을 수 있어서 객체/enum 등으로 컴파일 타임에 잡아내게 할 수 있음

## 추상 팩토리 패턴
- 인터페이스를 이용하여 서로 연관되어 있거나 의존하는 객체를 구상 클래스를 지정하지 않고 생성 가능
- 제품군을 생성하기 위한 인터페이스를 정의할 수 있음
    * 생산하는 제품을 다양하게 변주시켜야 할 때 `재료`를 더하는 용도

## 팩토리 메소드 패턴 vs 추상 팩토리 패턴
- 클래스를 써서 제품 만듦 / 객체를 써서 제품 만듦
- 상속을 통해 객체를 만듦 / 구성을 통해 객체를 만듦
- 클래스를 확장하고 팩토리 메소드를 오버라이드해야 함 / 제품군을 만들려는 추상 형식을 인스턴스화하여 객체에 전달
- 주로 하나의 제품을 생성하고 복잡한 인터페이스도 불필요하며 메소드도 하나만 있으면 됨 / 기본적으로 인터페이스가 큰 편이며 새로운 제품을 추가하려면 인터페이스를 바꿔야 함
- 어떤 구상 클래스를 필요로 할지 예상하지 못하는 경우, 클라이언트와 인스턴스를 분리해야 할 경우 / 클라이언트에서 서로 연관된 일련의 제품을 만들어야 하는 경우

## 디자인 원칙
- 캡슐화: 객체 생성에 대한 중복 코드를 제거하고 관리할 때 한 곳만 고려하면 됨
- 느슨한 결합: 애플리케이션의 구상 클래스에 대한 의존성을 줄여줌
- DIP: 구상 Creator 클래스 역시 추상 Product 클래스에 의존