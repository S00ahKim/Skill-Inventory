# OOP (Object Oriented Programming)
- 프로그래밍 패러다임 변천사
    1. 절차적 프로그래밍 (프로그램을 프로시저 호출로 구성; 함수 개념)
        * input -> output
        * 프로그램의 기능에 초점, 논리의 순서가 중요
    2. 구조적 프로그래밍 (프로그램을 제어 구조로 구성 ex. 순차, 선택, 반복;모듈 개념, GOTO문에 대한 의존성 약화)
        * 큰 문제를 작은 문제 해결 방식(모듈)의 결합으로 나누어 해결
        * Top-Down
    3. 객체지향 프로그래밍 (프로그램을 독립된 객체의 모임으로 구성)
        * 작은 문제를 해결하는 객체를 조합하여 큰 문제를 해결
        * Bottom-Up
    4. 번외, 함수형 프로그래밍
        * 데이터 처리를 함수의 계산으로 여기고, 프로그램을 함수의 조합으로 여긴다
        * 불변성) 관리해야 하는 `상태`와 `가변 데이터`를 멀리함
        * How를 설명하는 명령형 프로그래밍이 아니라, What을 말하는 선언형 프로그래밍 (함수는 역할이 아님)
        * 절차적 <-> 객체지향 이 아니듯, 함수형 <-> 객체지향 역시 아니다. 언어 하나에서 다양한 패러다임을 지원하는 추세.

- 객체지향의 4가지 특징
    1. 캡슐화
        * 객체가 스스로 자신의 상태를 책임지게 하여 해당 객체의 역할 수행에 집중하도록 자율성을 높일 수 있음
        * `데이터 캡슐화`: (데이터 구조 + 데이터를 다루는 방법; 역할)을 묶는 것. (ex. 클래스가 변수와 함수로 구성되어 있는 것)
        * `은닉화`: 그 변수를 외부에서 접근하지 못하게 하고, 함수로만 접근하게 하는 것
    2. 추상화: 공통의 속성과 기능을 묶어 이름을 붙이는 것 (ex. Class 정의)
    3. 상속: 부모 클래스의 속성과 기능을 받아 재사용하는 것
    4. 다형성: 같은 요청에 대해 다른 방식으로 응답하는 것
        * Overloading: 같은 이름의 메소드를 매개변수 타입, 개수 차이에 따라 다르게 정의하여 다양한 유형의 요청 처리.
        * Overriding: 상속받은 동일한 메소드 재정의. 매개변수 타입, 개수, 리턴 타입 등이 모두 일치해야 함.

- 좋은 객체지향
    * 코드는 유연하고, 확장할 수 있고, 유지보수가 용이하고, 재사용할 수 있어야 한다.
    * 요약하면, SOLID 원칙을 준수한 코드가 좋은 코드다.

- 객체지향의 단점?
    1. 개발 속도가 느리다.
        * 객체의 역할에 대한 이해가 필요하기 때문에 설계에 시간이 소요됨
        * 상속은 복잡한 코드를 만들 가능성을 높인다. (강한 coupling)
    2. 실행 속도가 느리다.
    3. 객체의 독립성을 너무 지키려다 보면, 같은 역할을 하는 코드를 재사용하게 된다.
        * 예) A(ㄱ->ㄴ->ㄷ) B(ㄱ->ㄹ->ㅁ) C(ㄴ->ㄹ->ㅂ)
        * 이렇게 흩어진 중복 부분을 `흩어진 관심사`라고 부른다.
        * 이 관심사를 관점(Aspect)로 모듈화하여 핵심 로직에서 분리해서 사용하자는 `AOP`가 등장