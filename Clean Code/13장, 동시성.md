# 동시성
- 객체는 처리의 추상화다. 스레드는 `일정의 추상화`다.
- 깔끔하게 다중 스레드 코드를 잘 짜는 것은 어렵다


## 여러 스레드를 동시에 돌리는 이유
- 동시성? 
    * 결합coupling을 없애는 전략
    * what, when을 분리하는 전략
        + 분리하면 구조&효율이 아주 나아짐. 시스템이 거대한 루프가 아니라 작은 협력 프로그램 여럿으로 보임. 그래서 이해가 쉽고, 문제 분리도 쉬움.
        + 참고) 스레드가 하나인 경우, what과 when이 밀접해서 디버깅할 때 breakpoint를 사용함.
- 왜 결합을 없애는 것이 좋은가?
    * 구조적 개선 ex. Servlet - 부분적인 동시성 관리, 요청 시 비동기 실행
    * 응답 시간, 작업 처리량 개선 ex. 웹 정보 수집기, 사용자가 많은 시스템
- 꼭 이런 것은 아니다
    * 항상 성능을 높인다                          (-> 특정한 경우 성능 향상)
    * 동시성을 구현해도 설계는 변하지 않는다           (-> 단일 스레드 시스템과 다중 스레드 시스템의 설계는 아주 다르다)
    * 컨테이너를 사용하면 동시성을 이해하지 않아도 된다   (-> 컨테이너 동작 원리, 동시 수정과 데드락을 어떻게 피하는지 알아야 함)
- 다만 이렇다
    * 동시성은 다소 부하를 유발한다 (성능 부하 & 코드량 증가)
    * 동시성은 복잡하다. 간단한 문제라도.
    * 일반적으로 동시성 버그는 재현이 어려워서 일회성 문제로 여겨져 무시당하기 쉽다
    * 동시성을 구현하려면 근본적인 설계 전략을 재고해야 한다


## 난관: 여러 스레드를 동시에 돌리는 어려움
- 두 스레드가 같은 변수를 동시에 참조할 가능성
- 정확히 어디에서 잘못된 처리가 일어날지 확인하기 어려움
- 이유: 바이트 코드를 고려할 때 두 스레드가 어떤 메서드를 실행하는 잠재 경로가 1만 개가 넘을 수도 있음


## 동시성 방어 원칙: 어려움에 대처하고 깨끗한 코드를 작성하는 방법
1. 단일 책임 원칙
2. 데이터 범위를 제한하라
3. 데이터 사본을 사용하라
4. 스레드는 가능한 독립적으로 구현하라
5. 라이브러리를 이해하라
6. 실행 모델을 이해하라
7. 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
8. 동기화하는 부분을 작게 만들어라
9. 올바른 종료 코드는 구현하기 어렵다


## 동시성을 테스트하는 방법과 문제점
1. 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
2. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 하라
3. 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
4. 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
5. 프로세서 수보다 많은 스레드를 돌려 보라
6. 다른 플랫폼에서 돌려 보라
7. 코드에 보조 코드를 넣어 돌려라. 강제로 실패하게 하라.
    * 직접 구현하기
    * 자동화