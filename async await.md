# 동기(Synchronous), 비동기(Asynchronous), Promise
1. 동기: 요청을 보낸 뒤 요청의 응답을 받고 다음 작업 실행
2. 비동기: 요청을 보낸 뒤 응답과 관계 없이 다음 작업 실행
3. Promise: 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타내는 객체


## 자바스크립트의 특성
1. Single Thread
    * 자바스크립트는 하나의 메인 쓰레드와 하나의 콜스택을 가짐
2. Synchronous
    * 자바스크립트 런타임 자체적으로 비동기 API를 지원하는 것이 아님
    * 비동기 처리는 런타임 환경에서 담당
3. Call Stack
    * 자바스크립트 런타임은 메모리 할당을 담당하는 `메모리 힙`과 코드가 호출되어 스택으로 쌓이는 `콜 스택`으로 구성됨
4. Blocking
    * 블로킹? 콜 스택이 멈춘 상태 (어떤 작업이 실행 완료되기를 기다리며 다른 작업을 수행할 수 없는 상태)

cf. `런타임`? 자바스크립트 엔진을 구동하는 환경. 브라우저 또는 Node.js 등


## 자바스크립트에서 비동기적으로 처리하기
-> 비동기 흐름 컨트롤 어려움


## 콜백함수 (Callback Function)
- 콜백함수? 특정 함수에 매개변수로 전달된 함수. 
- 동작 순서
    1. 비동기 요청 완료
    2. 요청의 응답(결과)이 콜백 큐로 전달
    3. 이벤트 루프를 통해 처리
- 사용예
- 특징
    * 전달된 함수 안에서 호출 및 실행됨. 
    * 전달된 함수가 콜백함수의 제어권을 가짐.
    * 처리되어야 하는 이벤트를 순차적으로 콜백 함수에 넣어주는 방식으로 구현.
- 단점
    * 콜백함수의 종료 시점 예측 불가 -> 콜백 지옥
    * 코드의 가독성이 떨어짐
    * 모든 콜백함수에서 각각 에러 핸들링 필요
    * 로직 변경의 어려움
- 개선 방안
    * 코딩 패턴
    * 또는... Promise


## 프로미스 (Promise)
- 프로미스? 비동기 작업이 갖게 될 미래의 완료/실패 + 결과값
- 동작 순서
    1. `new Promise()` 메소드 호출 시 바로 `Pending`
    2. 콜백함수 인자 `resolve` 호출시 -> `Fulfilled`(Settled) -> `then()`으로 결과값 받음
    3. 콜백함수 인자 `reject` 호출시 -> `Rejected`(Settled) -> `catch()`로 실패 결과값 받음
- 사용예
    ```javascript
    new Promise() // new 키워드로 메소드 호출
    new Promise(function(resolve, reject) {...}) // 인자로 resolve(비동기 처리 성공), reject(비동기 처리 실패)를 받는 콜백 함수를 넘겨줌
    ```
- 특징
    * 응답(결과)에 대한 사후 처리를 쉽게 제어할 수 있음.
    * 한 블록 내에 많은 중첩 함수를 작성할 필요 없음.
    * 코드의 가독성이 좋아짐.
    * then은 연속적으로 사용할 수 있음. (Promise Chaining)
    * 프로미스의 처리 과정을 상태값으로 가짐
      * `Pending`: 대기, 비동기 처리 작업이 아직 완료되지 않음.
      * `Fulfilled`: 성공, 비동기 처리 작업이 완료되어 프로미스가 결과값을 리턴함.
      * `Settled`: 결과 값이 성공/실패로 반환된 상태. 이 상태가 된 값은 재실행되지 않음.
      * `Rejected`: 실패, 비동기 처리 작업이 실패하거나 오류가 발생함.
- 단점


## async-await
- async-await? 비동기 함수를 만들 수 있는 키워드. async로 함수를 선언하면 AsyncFunction 객체를 반환하는 함수를 정의하는 것.
- 동작 순서
- 사용예
- 특징
    * 비동기 함수는 암시적으로 프로미스를 사용하여 결과를 리턴함.
    * 프로미스를 대체하는 개념이 아니라, 콜백과 프로미스의 단점을 보완함.
    * 프로미스를 사용하지만, then, catch를 컨트롤하지 않고 동기적 코드처럼 리턴값을 변수에 할당 가능. -> 코드 작성을 동기적 관점에서 할 수 있음
    * 코드의 가독성이 훨씬 나음. (여러개의 비동기 처리를 다루는 등)
    * async가 붙은 함수 내에서만 await를 사용 가능.
    * 에러 핸들링에 try-catch문 사용 가능.


# References
- [MDN Web Docs - Promise](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise)