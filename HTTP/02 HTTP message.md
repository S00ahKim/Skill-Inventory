# HTTP 메시지
참고: HTTP 완벽 가이드 I-01 (웹의 기초 > HTTP 메시지)


## 1. 메시지의 흐름
- HTTP 메시지? HTTP 애플리케이션 간에 주고받은 데이터 블록들
- 인바운드/아웃바운드? 트랜잭션 방향. 메시지가 서버로 향하는 것은 인바운드, 처리 이후 사용자 에이전트로 돌아오는 것은 아웃바운드
- 업스트림/다운스트림? 요청과 응답에 관계없이 메시지는 모두 '수신자' 즉 다운스트림으로 흐르며, 업스트림은 '발송자'를 의미하는 상대적 개념


## 2. HTTP 메시지의 공식 스펙, `시작줄`-`헤더`-`공백`-`개체 본문`
- 시작줄: 이것이 어떤 메시지인가
    * 요청 메시지와 응답 메시지의 형식은 시작줄에서만 차이를 보임.
        + 요청(request-line): `메서드-요청 URL-버전`
        + 응답(status-line): `버전-상태 코드-사유 구절`
    * `메서드`? 클라이언트 입장에서 서버가 리소스에 수행했으면 하는 동작
        + PUT: 서버에 요청 메시지의 본문을 저장한다.
        + POST: 서버가 처리해야 할 데이터를 보낸다. 
    * `요청 URL`? 요청 대상 리소스의 경로
    * `버전`? 이 메시지에서 사용 중인 HTTP 버전. 통신 상대의 능력(이 버전까지 이해 가능), 메시지 형식에 대한 단서 파악 용도. 가장 높은 버전을 가리킴. 2.22>2.3
    * `상태 코드`? 요청 중 일어난 일을 설명하는 숫자
    * `사유 구절`(reason-phrase)? 상태 코드에 대한 설명문 ex. NOT FOUND 
- 헤더: 속성
    * key-value 쌍의 목록 ex. `Content-length:19`
    * ex. 응답 생성 시간, 본문 크기, 본문 데이터 타입, 클라이언트가 수신 가능한 데이터 타입 등 각종 부가정보
    * key는 대소문자 구분 안함 / value는 띄어쓰기 허용, 대소문자 구분함
    * 표준 헤더 많음 / 필요시 임의의 헤더 추가 가능
- 공백 라인(CRLF; 줄바꿈) (무조건 있어야 함)
- 본문: 데이터 (없을 수도 있음)
- 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열 & 본문은 optional 데이터 덩어리
- HTTP/0.9 메시지는 초기 버전으로, 현재 널리 쓰이는 것에 비해 제약이 많음. 요청은 메서드+요청URL, 응답은 엔터티로만 구성.


## 3. 메서드
- 모든 서버가 모든 메서드를 구현하는 것은 아님 + 모든 메서드를 접근 가능하게 열어 두지도 않음
- 안전한 메서드? GET, HEAD. 서버에 요청으로 인한 결과가 없는 것이 기본. 구현에 따라 가능.
- 확장 메서드? HTTP는 필요에 따라 확장 가능하나, 이해 불가능한 애플리케이션들이 많을 것이므로, 프록시는 되도록 다운스트림으로 전달하고 불가능할 경우 501 응답
    * ex. LOCK(리소스 잠그기), MKCOL(문서 생성), COPY, MOVE etc.
    * 엄격하게 보내고 관대하게 받아들이라

### 메서드의 속성
- 안전(Safe): 호출해도 리소스를 변경하지 않는다.
    * GET, HEAD, OPTIONS, TRACE
    * 네트워크 오류 등으로 실패하는 케이스는 리소스 관점에서의 실패가 아니므로 여전히 안전하다
- 멱등(Idempotent): 몇 번을 호출해도 결과가 같다. 
    * GET, PUT, DELETE
    * 단, POST는 아님!
    * 자동 복구 매커니즘을 적용 가능한지에 대한 근거
    * 재요청 과정에서 값이 바뀌는 케이스는 고려하지 않는다
- 캐시 가능(Cacheable): 응답 결과 리소스를 캐시해서 사용해도 된다.
    * **GET**, **HEAD**, POST, PATCH
    * 뒤의 둘은 스펙상 가능하지만, 본문 내용까지 캐시 키로 고려해야 해서 구현이 어렵다

### 메서드의 종류
- GET
    * 리소스를 달라
    * 본문을 보낼 수도 있지만, 지원하지 않는 경우가 있으므로 비추
    * 조회의 경우엔 캐싱을 원활하게 하기 위해 GET을 쓴다. (다른 메서드에 캐시 설정을 하기는 좀 번거롭다)
- HEAD
    * 헤더만 달라
    * GET 과 같은데, 메시지(바디)는 제외하고 상태줄&헤더만 반환
    * 쓰이는 이유? 리소스 없이 리소스의 정보를 알아낼 수 있음 (ex. 타입, 존재 여부, 변경 여부 등. GET의 헤더와 같아야 함.)
- POST
    * 데이터를 보낸다
    * 용도는 정말 다양하다. 이걸 어떻게 처리할지 리소스마다 따로 정의해야 한다. (정해진 게 없음)
    * 일반적으로는 새 리소스 생성, 요청 데이터 처리, 다른 메서드로 처리하기 애매할 때 사용함
- PUT
    * 본문으로 대체하거나 없으면 새 문서를 만들어라
        + 주의! 리소스를 수정하는 게 아니다. **완전히 갈아치운다**. (특정 필드를 누락하면 값을 없앰)
    * 인증 필요할 가능성 높음
    * POST와의 차이? 클라이언트가 리소스를 식별함
- PATCH
    * 부분 변경
    * 리소스를 **부분적으로 변경**하는 경우에 사용
    * PATCH를 서버에서 지원하지 않는다면, POST를 쓰면 된다.
- DELETE
    * 리소스를 삭제하라 
- [사용빈도낮음] TRACE
    * 프록시를 거쳐 서버에 도착하는 과정을 추적하라
    * 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
    * 목표 서버에 가기 전에 거치는 애플리케이션들에서 어떤 변화가 있었는지, 즉 목표 서버에 도착한 요청이 어떤 모습인지 확인 가능
    * 목표 서버는 자신이 받은 요청 메시지를 본문에 넣어 응답함
    * 진단을 위해 사용되지만, 실제로 프록시는 메서드에 따라 처리를 달리하는 경우가 많은데 TRACE는 메서드 구분을 못하기 때문에 프록시에서 TRACE 처리 방식을 결정
- OPTIONS
    * 수행 가능한 메서드를 응답하라
    * 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명 (주로 CORS에서 사용)
- [사용빈도낮음] CONNECT
    * 대상 자원으로 식별되는 서버에 대한 터널을 설정


## 4. 상태 코드
> 서버가 임의의 상태 코드를 반환해도 클라이언트는 앞자리로 유추 가능
1. 1xx : 정보성 상태 코드 (ex. 100 Continue 클라이언트가 나머지 요청을 보내야 한다)
2. 2xx : 성공 상태 코드
    * 200은 기본적으로 요청된 리소스를 포함한다
    * 201은 PUT 메서드에 대한 응답으로, 생성된 개체에 대한 참조를 보내주어야 한다
    * 204는 본문이 없다 브라우저를 새 문서로 이동시키지 않고 갱신할 때 사용한다
3. 3xx : 리다이렉션 상태 코드. 리소스에 접근하기 위한 다른 위치나 대안을 제공
    * Location 헤더가 있으면 거기로 자동으로 이동함
    * 영구 리다이렉션: 특정 리소스의 URI가 영구적으로 이동 (ex. `/members` -> `/users`)
        + 301은 요청 메서드가 변경되며, 본문이 제거될 수 있을 때 사용한다
        + 308은 요청 메서드와 본문을 동일하게 유지할 때 사용한다
        + 검색 엔진이 변경을 인지함
    * 일시 리다이렉션: 일시적인 변경 (ex. 주문 완료 이후 주문 내역 화면으로 이동)
        + 302는 요청 메서드가 GET으로 변경되며, 본문이 제거될 **수** 있을 때 사용한다
        + 303은 명확하게 메서드가 GET으로 변경될 때 사용한다
        + 307은 요청 메서드와 본문을 동일하게 유지할 때 사용한다
    * 특수 리다이렉션: 결과 대신 캐시를 사용
        + 304는 캐시를 목적으로, 리소스가 수정되지 않았음을 알려줘서 로컬PC의 캐시를 재사용하게 유도할 때 사용한다
4. 4xx : 클라이언트 에러 상태 코드
    * 오류의 원인이 클라이언트에 있으므로, 재시도해도 성공할 가능성이 없다
    * 400은 스펙이 안 맞을 때 사용한다 (철저하게 validation해야 함)
    * 401은 **인증**되지 않았을 때 사용한다
        + 인증(authentication): 누구인지 확인
        + 인가(authorization): 누구인지 알아도 권한이 있는지 확인
    * 403은 인증은 됐는데 **인가**가 없을 때 사용한다
    * 404는 요청한 리소스가 없거나, 숨기고 싶을 때 사용한다
5. 5xx : 서버 에러 상태 코드
    * 500은 서버 내부 문제로 오류가 날 때 사용한다. 대부분 이걸로 처리할 수 있다.
    * 501은 클라이언트가 서버의 능력을 넘는 요청을 했을 때 사용된다 ex. 구현되지 않은 메서드 요청
    * 502는 프록시나 게이트웨이처럼 작동하는 서버가 다음 연결을 할 수 없을 때 사용된다
    * 503은 일시적 과부하 또는 예정된 작업으로 요청 처리가 불가능할 때 사용한다

### PRG(Post, Redirect, Get)
> POST로 주문 이후 새로고침하면 또 요청해서 중복 주문이 될 수 있음
- 일시적 리다이렉션
- 요새는 중복 주문 방지 팝업을 띄우는 추세이긴 함
- 또는 POST로 주문 후 응답을 3xx대로 주어 주문 결과 화면을 GET으로 리다이렉트해서 새로고침 해도 GET으로 조회

## 5. 헤더
1. 일반 헤더
    - 메시지에 대한 기본적인 정보 제공. 요청, 응답 양측이 사용
    - HTTP/1.0은 Cache-Control과 같은 `일반 캐시 헤더`로 로컬에 캐시할 수 있게 함. 캐시의 시점과 방식에 대한 지시자를 제공
2. 요청 헤더
    - 요청 메시지에서만 의미를 가짐. 클라이언트에 대한 정보 제공. 
    - `Accept 관련 헤더`로 클라이언트가 수용 가능한 메시지에 대해 서버에게 알림
    - `조건부 요청 헤더`로 클라이언트에게 없는 데이터만 서버에서 받아올 수 있음
    - `요청 보안 헤더`(Authorization, Cookie 등)로 클라이언트가 스스로를 인증하게 하여 안전한 트랜잭션을 만들 수 있음
    - `프록시 요청 헤더`로 인터넷 환경에서 프록시를 잘 기능하게 해줌
3. 응답 헤더
    - 응답 메시지에서만 의미를 가짐. 서버와 응답 본문에 대한 정보 제공. 
    - `협상 헤더`로 번역 문서를 처리할 수 있음
    - `응답 보안 헤더`로 기본적인 인증 요구를 할 수 있음
4. 엔터티 헤더
    - 엔터티 본문에 대한 헤더. 요청, 응답 양측이 사용
    - 메시지의 수신자에게 메시지가 다루는 것이 무엇인지 말해줌
    - `콘텐츠 헤더`로 콘텐츠에 대한 구체적인 정보를 제공
    - `엔터티 캐싱 헤더`로 엔터티 캐싱에 대한 정보(유효 여부 등) 제공
5. 확장 헤더
    - 애플리케이션 개발자가 정의한 헤더
    - HTTP가 이해하지 못하더라도 전달 가능