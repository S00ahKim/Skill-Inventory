# HTTP 메시지
참고: HTTP 완벽 가이드 I-01 (웹의 기초 > HTTP 메시지)


1. 메시지의 흐름
    - HTTP 메시지? HTTP 애플리케이션 간에 주고받은 데이터 블록들
    - 인바운드/아웃바운드? 트랜잭션 방향. 메시지가 서버로 향하는 것은 인바운드, 처리 이후 사용자 에이전트로 돌아오는 것은 아웃바운드
    - 업스트림/다운스트림? 요청과 응답에 관계없이 메시지는 모두 '수신자' 즉 다운스트림으로 흐르며, 업스트림은 '발송자'를 의미하는 상대적 개념
2. HTTP 메시지의 세 부분, `시작줄`-`헤더`-`개체 본문`
    - 시작줄: 이것이 어떤 메시지인가
        * 요청 메시지와 응답 메시지의 형식은 시작줄에서만 차이를 보임. (요청: `메서드-요청 URL-버전`, 응답: `버전-상태 코드-사유 구절`)
        * `메서드`? 클라이언트 입장에서 서버가 리소스에 수행했으면 하는 동작
            + PUT: 서버에 요청 메시지의 본문을 저장한다.
            + POST: 서버가 처리해야 할 데이터를 보낸다. 
        * `요청 URL`? 요청 대상 리소스의 경로
        * `버전`? 이 메시지에서 사용 중인 HTTP 버전. 통신 상대의 능력(이 버전까지 이해 가능), 메시지 형식에 대한 단서 파악 용도. 가장 높은 버전을 가리킴. 2.22>2.3
        * `상태 코드`? 요청 중 일어난 일을 설명하는 숫자
        * `사유 구절`(reason-phrase)? 상태 코드에 대한 설명문 ex. NOT FOUND 
    - 헤더: 속성
        * key-value 쌍의 목록 ex. `Content-length:19`
        * ex. 응답 생성 시간, 본문 크기, 본문 데이터 타입, 클라이언트가 수신 가능한 데이터 타입 등
    - 본문: 데이터 (없을 수도 있음)
    - 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열 & 본문은 optional 데이터 덩어리
    - HTTP/0.9 메시지는 초기 버전으로, 현재 널리 쓰이는 것에 비해 제약이 많음. 요청은 메서드+요청URL, 응답은 엔터티로만 구성.
3. 메서드
    - 모든 서버가 모든 메서드를 구현하는 것은 아님 + 모든 메서드를 접근 가능하게 열어 두지도 않음
    - 안전한 메서드? GET, HEAD. 서버에 요청으로 인한 결과가 없는 것이 기본. 구현에 따라 가능.
    - 확장 메서드? HTTP는 필요에 따라 확장 가능하나, 이해 불가능한 애플리케이션들이 많을 것이므로, 프록시는 되도록 다운스트림으로 전달하고 불가능할 경우 501 응답
        * ex. LOCK(리소스 잠그기), MKCOL(문서 생성), COPY, MOVE etc.
        * 엄격하게 보내고 관대하게 받아들이라
    1. GET: 리소스를 달라
    2. HEAD: 헤더만 달라 (쓰이는 이유? 리소스 없이 리소스의 정보를 알아낼 수 있음 ex. 타입, 존재 여부, 변경 여부 등. GET의 헤더와 같아야 함.)
    3. PUT: 본문으로 새 문서를 만들거나, 본문으로 문서를 교체하라 (인증 필요할 가능성 높음)
    4. POST: 데이터를 보낸다 (보낸다는 것 자체에 집중. PUT은 서버의 리소스에 접근.)
    5. TRACE: 프록시를 거쳐 서버에 도착하는 과정을 추적하라
          * 목표 서버에 가기 전에 거치는 애플리케이션들에서 어떤 변화가 있었는지, 즉 목표 서버에 도착한 요청이 어떤 모습인지 확인 가능
          * 목표 서버는 자신이 받은 요청 메시지를 본문에 넣어 응답함
          * 진단을 위해 사용되지만, 실제로 프록시는 메서드에 따라 처리를 달리하는 경우가 많은데 TRACE는 메서드 구분을 못하기 때문에 프록시에서 TRACE 처리 방식을 결정
    6. OPTIONS: 수행 가능한 메서드를 응답하라
    7. DELETE: 리소스를 삭제하라 
4. 상태 코드
      1. 1xx : 정보성 상태 코드 (ex. 100 Continue 클라이언트가 나머지 요청을 보내야 한다)
      2. 2xx : 성공 상태 코드
            * 200은 기본적으로 요청된 리소스를 포함한다
            * 201은 PUT 메서드에 대한 응답으로, 생성된 개체에 대한 참조를 보내주어야 한다
            * 204는 본문이 없다 브라우저를 새 문서로 이동시키지 않고 갱신할 때 사용한다
      3. 3xx : 리다이렉션 상태 코드. 리소스에 접근하기 위한 다른 위치나 대안을 제공
      4. 4xx : 클라이언트 에러 상태 코드
      5. 5xx : 서버 에러 상태 코드
            * 501은 클라이언트가 서버의 능력을 넘는 요청을 했을 때 사용된다 ex. 구현되지 않은 메서드 요청
            * 502는 프록시나 게이트웨이처럼 작동하는 서버가 다음 연결을 할 수 없을 때 사용된다
5. 헤더
    1. 일반 헤더
          - 메시지에 대한 기본적인 정보 제공. 요청, 응답 양측이 사용
          - HTTP/1.0은 Cache-Control과 같은 `일반 캐시 헤더`로 로컬에 캐시할 수 있게 함. 캐시의 시점과 방식에 대한 지시자를 제공
    2. 요청 헤더
          - 요청 메시지에서만 의미를 가짐. 클라이언트에 대한 정보 제공. 
          - `Accept 관련 헤더`로 클라이언트가 수용 가능한 메시지에 대해 서버에게 알림
          - `조건부 요청 헤더`로 클라이언트에게 없는 데이터만 서버에서 받아올 수 있음
          - `요청 보안 헤더`(Authorization, Cookie 등)로 클라이언트가 스스로를 인증하게 하여 안전한 트랜잭션을 만들 수 있음
          - `프록시 요청 헤더`로 인터넷 환경에서 프록시를 잘 기능하게 해줌
    3. 응답 헤더
          - 응답 메시지에서만 의미를 가짐. 서버와 응답 본문에 대한 정보 제공. 
          - `협상 헤더`로 번역 문서를 처리할 수 있음
          - `응답 보안 헤더`로 기본적인 인증 요구를 할 수 있음
    4. 엔터티 헤더
          - 엔터티 본문에 대한 헤더. 요청, 응답 양측이 사용
          - 메시지의 수신자에게 메시지가 다루는 것이 무엇인지 말해줌
          - `콘텐츠 헤더`로 콘텐츠에 대한 구체적인 정보를 제공
          - `엔터티 캐싱 헤더`로 엔터티 캐싱에 대한 정보(유효 여부 등) 제공
    5. 확장 헤더
          - 애플리케이션 개발자가 정의한 헤더
          - HTTP가 이해하지 못하더라도 전달 가능