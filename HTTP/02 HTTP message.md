# HTTP 메시지
참고: HTTP 완벽 가이드 I-01 (웹의 기초 > HTTP 메시지)


1. 메시지의 흐름
    - HTTP 메시지? HTTP 애플리케이션 간에 주고받은 데이터 블록들
    - 인바운드/아웃바운드? 트랜잭션 방향. 메시지가 서버로 향하는 것은 인바운드, 처리 이후 사용자 에이전트로 돌아오는 것은 아웃바운드
    - 업스트림/다운스트림? 요청과 응답에 관계없이 메시지는 모두 '수신자' 즉 다운스트림으로 흐르며, 업스트림은 '발송자'를 의미하는 상대적 개념
2. HTTP 메시지의 세 부분, `시작줄`-`헤더`-`개체 본문`
    - 시작줄: 이것이 어떤 메시지인가
        * 요청 메시지와 응답 메시지의 형식은 시작줄에서만 차이를 보임. (요청: `메서드-요청 URL-버전`, 응답: `버전-상태 코드-사유 구절`)
        * `메서드`? 클라이언트 입장에서 서버가 리소스에 수행했으면 하는 동작
            + PUT: 서버에 요청 메시지의 본문을 저장한다.
            + POST: 서버가 처리해야 할 데이터를 보낸다. 
        * `요청 URL`? 요청 대상 리소스의 경로
        * `버전`? 이 메시지에서 사용 중인 HTTP 버전. 통신 상대의 능력(이 버전까지 이해 가능), 메시지 형식에 대한 단서 파악 용도. 가장 높은 버전을 가리킴. 2.22>2.3
        * `상태 코드`? 요청 중 일어난 일을 설명하는 숫자
        * `사유 구절`(reason-phrase)? 상태 코드에 대한 설명문 ex. NOT FOUND 
    - 헤더: 속성
        * key-value 쌍의 목록 ex. `Content-length:19`
        * ex. 응답 생성 시간, 본문 크기, 본문 데이터 타입, 클라이언트가 수신 가능한 데이터 타입 등
    - 본문: 데이터 (없을 수도 있음)
    - 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열 & 본문은 optional 데이터 덩어리
    - HTTP/0.9 메시지는 초기 버전으로, 현재 널리 쓰이는 것에 비해 제약이 많음. 요청은 메서드+요청URL, 응답은 엔터티로만 구성.
3. 메서드
    - 모든 서버가 모든 메서드를 구현하는 것은 아님 + 모든 메서드를 접근 가능하게 열어 두지도 않음
    - 안전한 메서드? GET, HEAD. 서버에 요청으로 인한 결과가 없는 것이 기본. 구현에 따라 가능.
    - 확장 메서드? HTTP는 필요에 따라 확장 가능하나, 이해 불가능한 애플리케이션들이 많을 것이므로, 프록시는 되도록 다운스트림으로 전달하고 불가능할 경우 501 응답
        * ex. LOCK(리소스 잠그기), MKCOL(문서 생성), COPY, MOVE etc.
        * 엄격하게 보내고 관대하게 받아들이라
    1. GET: 리소스를 달라
    2. HEAD: 헤더만 달라 (쓰이는 이유? 리소스 없이 리소스의 정보를 알아낼 수 있음 ex. 타입, 존재 여부, 변경 여부 등. GET의 헤더와 같아야 함.)
    3. PUT: 본문으로 새 문서를 만들거나, 본문으로 문서를 교체하라 (인증 필요할 가능성 높음)
    4. POST: 데이터를 보낸다 (보낸다는 것 자체에 집중. PUT은 서버의 리소스에 접근.)
    5. TRACE: 프록시를 거쳐 서버에 도착하는 과정을 추적하라
          * 목표 서버에 가기 전에 거치는 애플리케이션들에서 어떤 변화가 있었는지, 즉 목표 서버에 도착한 요청이 어떤 모습인지 확인 가능
          * 목표 서버는 자신이 받은 요청 메시지를 본문에 넣어 응답함
          * 진단을 위해 사용되지만, 실제로 프록시는 메서드에 따라 처리를 달리하는 경우가 많은데 TRACE는 메서드 구분을 못하기 때문에 프록시에서 TRACE 처리 방식을 결정
    6. OPTIONS: 수행 가능한 메서드를 응답하라
    7. DELETE: 리소스를 삭제하라 
4. 상태 코드