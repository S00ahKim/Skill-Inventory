# HTTP 메시지
참고: HTTP 완벽 가이드 I-01 (웹의 기초 > HTTP 메시지)


## 1. 메시지의 흐름
- HTTP 메시지? HTTP 애플리케이션 간에 주고받은 데이터 블록들
- 인바운드/아웃바운드? 트랜잭션 방향. 메시지가 서버로 향하는 것은 인바운드, 처리 이후 사용자 에이전트로 돌아오는 것은 아웃바운드
- 업스트림/다운스트림? 요청과 응답에 관계없이 메시지는 모두 '수신자' 즉 다운스트림으로 흐르며, 업스트림은 '발송자'를 의미하는 상대적 개념


## 2. HTTP 메시지의 공식 스펙, `시작줄`-`헤더`-`공백`-`개체 본문`
- 시작줄: 이것이 어떤 메시지인가
    * 요청 메시지와 응답 메시지의 형식은 시작줄에서만 차이를 보임.
        + 요청(request-line): `메서드-요청 URL-버전`
        + 응답(status-line): `버전-상태 코드-사유 구절`
    * `메서드`? 클라이언트 입장에서 서버가 리소스에 수행했으면 하는 동작
        + PUT: 서버에 요청 메시지의 본문을 저장한다. 기존에 있는 것을 대체. 클라가 리소스의 uri를 알고 있다.
        + POST: 서버가 처리해야 할 데이터를 보낸다. 새로운 것을 생성. 클라가 리소스의 uri를 모른다.
    * `요청 URL`? 요청 대상 리소스의 경로
    * `버전`? 이 메시지에서 사용 중인 HTTP 버전. 통신 상대의 능력(이 버전까지 이해 가능), 메시지 형식에 대한 단서 파악 용도. 가장 높은 버전을 가리킴. 2.22>2.3
    * `상태 코드`? 요청 중 일어난 일을 설명하는 숫자
    * `사유 구절`(reason-phrase)? 상태 코드에 대한 설명문 ex. NOT FOUND 
- 헤더: 속성
    * key-value 쌍의 목록 ex. `Content-length:19`
    * ex. 응답 생성 시간, 본문 크기, 본문 데이터 타입, 클라이언트가 수신 가능한 데이터 타입 등 각종 부가정보
    * key는 대소문자 구분 안함 / value는 띄어쓰기 허용, 대소문자 구분함
    * 표준 헤더 많음 / 필요시 임의의 헤더 추가 가능
- 공백 라인(CRLF; 줄바꿈) (무조건 있어야 함)
- 본문: 데이터 (없을 수도 있음)
- 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열 & 본문은 optional 데이터 덩어리
- HTTP/0.9 메시지는 초기 버전으로, 현재 널리 쓰이는 것에 비해 제약이 많음. 요청은 메서드+요청URL, 응답은 엔터티로만 구성.


## 3. 메서드
- 모든 서버가 모든 메서드를 구현하는 것은 아님 + 모든 메서드를 접근 가능하게 열어 두지도 않음
- 안전한 메서드? GET, HEAD. 서버에 요청으로 인한 결과가 없는 것이 기본. 구현에 따라 가능.
- 확장 메서드? HTTP는 필요에 따라 확장 가능하나, 이해 불가능한 애플리케이션들이 많을 것이므로, 프록시는 되도록 다운스트림으로 전달하고 불가능할 경우 501 응답
    * ex. LOCK(리소스 잠그기), MKCOL(문서 생성), COPY, MOVE etc.
    * 엄격하게 보내고 관대하게 받아들이라

### 메서드의 속성
- 안전(Safe): 호출해도 리소스를 변경하지 않는다.
    * GET, HEAD, OPTIONS, TRACE
    * 네트워크 오류 등으로 실패하는 케이스는 리소스 관점에서의 실패가 아니므로 여전히 안전하다
- 멱등(Idempotent): 몇 번을 호출해도 결과가 같다. 
    * GET, PUT, DELETE
    * 단, POST는 아님!
    * 자동 복구 매커니즘을 적용 가능한지에 대한 근거
    * 재요청 과정에서 값이 바뀌는 케이스는 고려하지 않는다
- 캐시 가능(Cacheable): 응답 결과 리소스를 캐시해서 사용해도 된다.
    * **GET**, **HEAD**, POST, PATCH
    * 뒤의 둘은 스펙상 가능하지만, 본문 내용까지 캐시 키로 고려해야 해서 구현이 어렵다

### 메서드의 종류
- GET
    * 리소스를 달라
    * 본문을 보낼 수도 있지만, 지원하지 않는 경우가 있으므로 비추
    * 조회의 경우엔 캐싱을 원활하게 하기 위해 GET을 쓴다. (다른 메서드에 캐시 설정을 하기는 좀 번거롭다)
- HEAD
    * 헤더만 달라
    * GET 과 같은데, 메시지(바디)는 제외하고 상태줄&헤더만 반환
    * 쓰이는 이유? 리소스 없이 리소스의 정보를 알아낼 수 있음 (ex. 타입, 존재 여부, 변경 여부 등. GET의 헤더와 같아야 함.)
- POST
    * 데이터를 보낸다
    * 용도는 정말 다양하다. 이걸 어떻게 처리할지 리소스마다 따로 정의해야 한다. (정해진 게 없음)
    * 일반적으로는 새 리소스 생성, 요청 데이터 처리, 다른 메서드로 처리하기 애매할 때 사용함
- PUT
    * 본문으로 대체하거나 없으면 새 문서를 만들어라
        + 주의! 리소스를 수정하는 게 아니다. **완전히 갈아치운다**. (특정 필드를 누락하면 값을 없앰)
    * 인증 필요할 가능성 높음
    * POST와의 차이? 클라이언트가 리소스를 식별함
- PATCH
    * 부분 변경
    * 리소스를 **부분적으로 변경**하는 경우에 사용
    * PATCH를 서버에서 지원하지 않는다면, POST를 쓰면 된다.
- DELETE
    * 리소스를 삭제하라 
- [사용빈도낮음] TRACE
    * 프록시를 거쳐 서버에 도착하는 과정을 추적하라
    * 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
    * 목표 서버에 가기 전에 거치는 애플리케이션들에서 어떤 변화가 있었는지, 즉 목표 서버에 도착한 요청이 어떤 모습인지 확인 가능
    * 목표 서버는 자신이 받은 요청 메시지를 본문에 넣어 응답함
    * 진단을 위해 사용되지만, 실제로 프록시는 메서드에 따라 처리를 달리하는 경우가 많은데 TRACE는 메서드 구분을 못하기 때문에 프록시에서 TRACE 처리 방식을 결정
- OPTIONS
    * 수행 가능한 메서드를 응답하라
    * 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명 (주로 CORS에서 사용)
- [사용빈도낮음] CONNECT
    * 대상 자원으로 식별되는 서버에 대한 터널을 설정


## 4. 상태 코드
> 서버가 임의의 상태 코드를 반환해도 클라이언트는 앞자리로 유추 가능
1. 1xx : 정보성 상태 코드 (ex. 100 Continue 클라이언트가 나머지 요청을 보내야 한다)
2. 2xx : 성공 상태 코드
    * 200은 기본적으로 요청된 리소스를 포함한다
    * 201은 PUT 메서드에 대한 응답으로, 생성된 개체에 대한 참조를 보내주어야 한다
    * 204는 본문이 없다 브라우저를 새 문서로 이동시키지 않고 갱신할 때 사용한다
3. 3xx : 리다이렉션 상태 코드. 리소스에 접근하기 위한 다른 위치나 대안을 제공
    * Location 헤더가 있으면 거기로 자동으로 이동함
    * 영구 리다이렉션: 특정 리소스의 URI가 영구적으로 이동 (ex. `/members` -> `/users`)
        + 301은 요청 메서드가 변경되며, 본문이 제거될 수 있을 때 사용한다
        + 308은 요청 메서드와 본문을 동일하게 유지할 때 사용한다
        + 검색 엔진이 변경을 인지함
    * 일시 리다이렉션: 일시적인 변경 (ex. 주문 완료 이후 주문 내역 화면으로 이동)
        + 302는 요청 메서드가 GET으로 변경되며, 본문이 제거될 **수** 있을 때 사용한다
        + 303은 명확하게 메서드가 GET으로 변경될 때 사용한다
        + 307은 요청 메서드와 본문을 동일하게 유지할 때 사용한다
    * 특수 리다이렉션: 결과 대신 캐시를 사용
        + 304는 캐시를 목적으로, 리소스가 수정되지 않았음을 알려줘서 로컬PC의 캐시를 재사용하게 유도할 때 사용한다
4. 4xx : 클라이언트 에러 상태 코드
    * 오류의 원인이 클라이언트에 있으므로, 재시도해도 성공할 가능성이 없다
    * 400은 스펙이 안 맞을 때 사용한다 (철저하게 validation해야 함)
    * 401은 **인증**되지 않았을 때 사용한다
        + 인증(authentication): 누구인지 확인
        + 인가(authorization): 누구인지 알아도 권한이 있는지 확인
    * 403은 인증은 됐는데 **인가**가 없을 때 사용한다
    * 404는 요청한 리소스가 없거나, 숨기고 싶을 때 사용한다
5. 5xx : 서버 에러 상태 코드
    * 500은 서버 내부 문제로 오류가 날 때 사용한다. 대부분 이걸로 처리할 수 있다.
    * 501은 클라이언트가 서버의 능력을 넘는 요청을 했을 때 사용된다 ex. 구현되지 않은 메서드 요청
    * 502는 프록시나 게이트웨이처럼 작동하는 서버가 다음 연결을 할 수 없을 때 사용된다
    * 503은 일시적 과부하 또는 예정된 작업으로 요청 처리가 불가능할 때 사용한다

### PRG(Post, Redirect, Get)
> POST로 주문 이후 새로고침하면 또 요청해서 중복 주문이 될 수 있음
- 일시적 리다이렉션
- 요새는 중복 주문 방지 팝업을 띄우는 추세이긴 함
- 또는 POST로 주문 후 응답을 3xx대로 주어 주문 결과 화면을 GET으로 리다이렉트해서 새로고침 해도 GET으로 조회

## 5. 헤더
> 각종 부가 정보를 넣을 수 있으며, 표준 헤더의 양도 상당하다.

### 초창기의 헤더 구분
1. 일반 헤더
    - 메시지에 대한 기본적인 정보 제공. 요청, 응답 양측이 사용
    - HTTP/1.0은 Cache-Control과 같은 `일반 캐시 헤더`로 로컬에 캐시할 수 있게 함. 캐시의 시점과 방식에 대한 지시자를 제공
2. 요청 헤더
    - 요청 메시지에서만 의미를 가짐. 클라이언트에 대한 정보 제공. 
    - `Accept 관련 헤더`로 클라이언트가 수용 가능한 메시지에 대해 서버에게 알림
    - `조건부 요청 헤더`로 클라이언트에게 없는 데이터만 서버에서 받아올 수 있음
    - `요청 보안 헤더`(Authorization, Cookie 등)로 클라이언트가 스스로를 인증하게 하여 안전한 트랜잭션을 만들 수 있음
    - `프록시 요청 헤더`로 인터넷 환경에서 프록시를 잘 기능하게 해줌
3. 응답 헤더
    - 응답 메시지에서만 의미를 가짐. 서버와 응답 본문에 대한 정보 제공. 
    - `협상 헤더`로 번역 문서를 처리할 수 있음
    - `응답 보안 헤더`로 기본적인 인증 요구를 할 수 있음
4. 엔터티 헤더
    - 엔터티 본문에 대한 헤더. 요청, 응답 양측이 사용
    - 메시지의 수신자에게 메시지가 다루는 것이 무엇인지 말해줌
    - `콘텐츠 헤더`로 콘텐츠에 대한 구체적인 정보를 제공
    - `엔터티 캐싱 헤더`로 엔터티 캐싱에 대한 정보(유효 여부 등) 제공
5. 확장 헤더
    - 애플리케이션 개발자가 정의한 헤더
    - HTTP가 이해하지 못하더라도 전달 가능

### 최근(RFC723x)의 헤더 구분
- 엔티티(Entity) -> 표현(Representation)
- 표현(Representation) = 메타데이터(representation Metadata; 표현 데이터를 해석할 수 있는 정보) + 데이터(Representation Data; 실제 데이터)
- 메시지 본문(message body, 페이로드)을 통해 표현 데이터를 전달

1. 표현 헤더 (요청&응답)
    - `Content-Type`: 표현 데이터의 형식 (미디어 타입, 문자 인코딩)
    - `Content-Encoding`: 표현 데이터의 압축 방식 ()
    - `Content-Language`: 표현 데이터의 자연 언어 (표현 데이터의 자연 언어)
    - `Content-Length`: 표현 데이터의 길이 (바이트 단위, Transfer-Encoding의 경우 사용 불가)
2. 협상 헤더 (요청)
    > 모든 서버가 요청대로 주는 것은 아니지만, 가능한 곳에서는 요청대로 준다. 
    - `Accept`: 클라이언트가 선호하는 미디어 타입 전달
    - `Accept-Charset`: 클라이언트가 선호하는 문자 인코딩
    - `Accept-Encoding`: 클라이언트가 선호하는 압축 인코딩
    - `Accept-Language`: 클라이언트가 선호하는 자연 언어
    - cf. 우선순위 부여 가능 (ex. `Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7`)
    - cf. 구체적인 것이 우선한다 (ex. `Accept: text/*, text/plain, text/plain;format=flowed, */*`에서는 자세히 기입한 요소 순으로 우선순위가 높다. 각각 3, 2, 1, 4 순위)
3. 전송 방식 헤더
    - `Transfer-Encoding`, `Range`, `Content-Range`
    - 전송 방식?
        * 단순 전송 ex. `Content-Length: 3423`
        * 압축 전송 ex. `Content-Encoding: gzip`
        * 분할 전송 ex. `Transfer-Encoding: chunked` (덩어리로 쪼개 보냄)
        * 범위 전송
            + 요청 ex. `Range: bytes=1001-2000`
            + 응답 ex. `Content-Range: bytes 1001-2000 / 2000`
4. 일반 정보 헤더
    - `From`: 유저 에이전트의 이메일 정보 (요청; 잘 사용되지 않음, 검색 엔진에서 크롤링 시 문제가 생길 경우 연락할 담당자 등)
    - `Referer`: 이전 웹 페이지 주소 (요청)
    - `User-Agent`: 유저 에이전트 애플리케이션 정보 (요청)
    - `Server`: 요청을 처리하는 오리진 서버의 소프트웨어 정보 (응답; 오리진 서버란 최종으로 표현 데이터를 주는 서버)
    - `Date`: 메시지가 생성된 날짜 (응답; 초기에는 요청에서도 썼지만 최근의 표준은 응답에서만)
5. 특별한 정보 헤더
    - `Host`: **필수** 요청한 호스트 정보(도메인) ex. `Host: aaa.com` (가상호스트 대응)
    - `Location`: 페이지 리다이렉션
        + 201 (Created): 요청에 의해 생성된 리소스 URI
        + 3xx (Redirection): 요청을 자동으로 리디렉션하기 위한 대상 리소스
    - `Allow`: 허용 가능한 HTTP 메서드
        + 405 (Method Not Allowed)에서 응답에 포함해야함
    - `Retry-After`: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
        + 503 (Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있음
6. 인증 헤더
    - `Authorization`: 클라이언트 인증 정보를 서버에 전달 (다양한 인증 매커니즘이 있는데, 각각 여기에 들어갈 값이 다름)
    - `WWW-Authenticate`: 리소스 접근시 필요한 인증 방법 정의
        + 401 Unauthorized 응답과 함께 사용
7. 쿠키 헤더
    > 사용자 로그인 세션 관리 & 광고 정보 트래킹 등에 사용됨 / 보안 주의 (민감 정보 XX) / 최소한으로 사용해야 함
    - `Set-Cookie`: 서버에서 클라이언트로 쿠키 전달(응답)
        * 생명주기
            + `Set-Cookie: expires=Sat, 26-Dec-2020 04:39:21 GMT` 만료일이 되면 쿠키 삭제
            + `Set-Cookie: max-age=3600` (3600초) 0이나 음수를 지정하면 쿠키 삭제
        * 도메인
            + `Set-Cookie: domain=example.org` 명시한 문서 기준 도메인 + 서브 도메인 모두 쿠키 접근 가능
        * 경로
            + `Set-Cookie: path=/home` 이 경로를 포함한 하위 경로 페이지만 쿠키 접근 (보통은 path=/)
        * 보안
            + `Set-Cookie: Secure` https인 경우에만 전송
            + `Set-Cookie: HttpOnly` 자바스크립트(ex. document.cookie)에서 접근 불가(XSS 공격 방지), HTTP 전송에만 사용
            + `Set-Cookie: SameSite`: 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송(XSRF 공격 방지)
    - `Cookie`: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달
    - cf. 쿠키를 사용하지 않으면 요청할 때마다 사용자 개인 정보가 포함된다 (why? stateless)