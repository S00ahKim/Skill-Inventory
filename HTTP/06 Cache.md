#### 바로가기
- [Cache](#cache)
  - [적중과 부적중](#적중과-부적중)
  - [캐시 토폴로지](#캐시-토폴로지)
    - [개인 전용 캐시 (private cache)](#개인-전용-캐시-private-cache)
    - [공용 캐시 (public cache)](#공용-캐시-public-cache)
    - [프록시 캐시 계층들](#프록시-캐시-계층들)
    - [캐시망, 콘텐츠 라우팅, 피어링](#캐시망-콘텐츠-라우팅-피어링)
  - [캐시 처리단계](#캐시-처리단계)
  - [사본을 신선하게 유지하기](#사본을-신선하게-유지하기)
  - [캐시 제어](#캐시-제어)
  - [캐시 제어 설정](#캐시-제어-설정)
  - [자세한 알고리즘](#자세한-알고리즘)
  - [캐시와 광고](#캐시와-광고)

---

# Cache
- 웹 캐시: 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치
- 장점
    * 불필요한 데이터 전송 줄임 -> 네트워크 비용 감소
        + 똑같은 바이트들이 네트워크를 통해 계속 반복 이동
        + 값비싼 네트워크 대역폭을 낭비 & 전송 속도 저하 & 웹 서버에 부하를 줌
        + 캐시 사용 시, 첫 번째 서버 응답은 캐시에 보관되며, 캐시된 사본이 그 뒤 요청에 대해 응답함
    * 네트워크 병목 감소 / 대역폭 늘리지 않고도 페이지의 빠른 로드 가능
        + 원격 서버보다 로컬 네트워크에 더 넓은 대역폭을 제공
            - (캐시 미사용) 서버 접근 속도 = 경로에 있는 가장 느린 네트워크 속도
            - (캐시 사용) LAN에 있는 캐시로부터 사본 가져옴 -> 성능 대폭 개선
        + 대역폭: 네트워크 속도와 문서 크기에 따라 **전송 시간**에 영향을 많이 줌
    * 원 서버에 대한 요청을 줄임 -> 서버는 부하를 줄일 수 있음 & 더 빠르게 응답 가능
        + 속보, 스팸, 특정 사건 등으로 트래픽이 급증할 경우(Flash Crowds), 서버에 과부하를 줄 수 있음
    * 거리로 인한 지연 감소
        + 원거리 요청이 가지는 어쩔 수 없는 지연: 모든 라우터 각각에서 발생하는 지연 & 빛의 속도 자체로 지연
- point
    * 어떻게 캐시가 성능을 개선하고 비용을 줄이나? 
    * 어떻게 그 효과를 측정하는가?
    * 캐시를 어디에 위치시켜야 한느가?
    * HTTP가 어떻게 캐시된 사본을 fresh하게 유지하는가?
    * 캐시는 어떻게 다른 캐시/서버와 상호작용하는가?


## 적중과 부적중
- 적중(hit): 캐시에 저장된 사본으로 요청이 처리됨
- 부적중(miss): 대응하는 사본이 없어 원 서버로 요청이 전달됨
- 재검사(revalidation): 캐시에 저장된 사본이 최신인지 점검하는 것 (=신선도 검사)
    * 충분히 오래된 경우에만 재검사
        + [재검사 규칙](#사본을-신선하게-유지하기)
        + `If-Modified-Since` 헤더를 추가하여 GET 요청을 보내면, 캐시된 시간 이후 변경됐을 때만 사본을 보내달라는 의미. 
        + 응답으로는 적중/부적중/삭제가 올 수 있음.
    * 재검사 적중/느린 적중
        + 304 Not Modified
        + 재검사 후 변경이 없음을 확인하고 응답하는 경우
        + 부적중보다 빠르고 적중보다 느림
    * 재검사 부적중
        + 200 OK & 콘텐츠 전체
        + 일반 부적중과 거의 같은 속도로 수행
    * 객체 삭제
        + 404 Not Found
        + 캐시는 사본을 삭제함
- 캐시/문서 적중률/적중비
    * 0~1, 1이 all 적중, 0.4면 좋은 편
    * 얼마나 많은 트랜잭션을 외부로 내보내지 않았는가
    * 전체 대기 시간이 줄어듦
- 바이트 적중률
    * 트래픽의 바이트 단위로 요금이 산정될 경우 유용. 트래픽이 절감된 정도를 포착함.
    * 얼마나 많은 바이트가 인터넷으로 나가지 않았는가
    * 대역폭 절약 최적화
- 적중/부적중의 구별: HTTP가 응답에 이를 명시하는 것은 **없음**
    * 응답의 Date 헤더를 현재 시각과 비교 -> 생성일이 오래되었음 -> 캐시된 응답
    * 응답이 얼마나 오래된 것인지를 말하는 Age 헤더 이용


## 캐시 토폴로지
- 토폴로지? 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식

### 개인 전용 캐시 (private cache)
- 한 명의 사용자가 자주 찾는 페이지를 담음
- 많은 에너지/저장 공간을 필요로 하지 않음
- 사용자가 설정을 지정
- ex. 브라우저: PC의 디스크, 메모리에 캐시함 (chrome `about:cache`)

### 공용 캐시 (public cache)
- 사용자 집단에게 자주 쓰이는 페이지를 담음
- 로컬 캐시에서 문서를 제공하거나 사용자 입장에서 서버에 접근함
- 프록시 캐시는 프록시 규칙을 따름. 수동으로 지정 / 자동설정 파일 설정 / 인터셉트 프록시를 사용

### 프록시 캐시 계층들
- 캐시 계층: 작은 캐시에서 miss -> 부모 캐시(더 크고, 더 고성능)가 그 트래픽을 처리하게 함
- 클라이언트 주위에 작고 저렴한 캐시를 사용하고, 계층 상단에는 크고 강력한 캐시를 사용
- 캐시 계층이 깊다면 요청이 캐시 연쇄를 따라가게 되고, 이게 길어질수록 각 중간 프록시에 성능 저하가 발생 -> 보통 네트워크는 두 개 혹은 세 개의 프록시만 거치도록 제한

### 캐시망, 콘텐츠 라우팅, 피어링
- 캐시망: 캐시 커뮤니케이션에 대한 동적 결정
    1. 부모 캐시 / 원 서버 (by URL)
    2. 특정 부모 캐시 동적 선택 (by URL)
    3. 부모 캐시에 가기 전에 사본을 로컬에서 탐색
    4. 다른 캐시가 부분적으로 접근하는 것을 허용 but 접근해서 다른 네트워크로 건너가는 것 불가
- 형제 캐시: 상호 이득을 위해 캐시를 연결하고 서로의 탐색 지원
    * HTTP 미지원
    * 인터넷 캐시 프로토콜(ICP)/하이퍼텍스트 캐시 프로토콜(HTCP) 등으로 HTTP 확장


## 캐시 처리단계
1. 요청 받기
    - 네트워크로부터 도착한 요청 메시지를 읽음
    - 고성능 캐시는 여러 개의 커넥션으로부터 데이터를 동시에 읽고 트랜잭션 처리를 시작할 수 있음
2. 파싱
    - 메시지를 파싱하여 URL과 헤더들을 추출
    - 대소문자, 날짜 형식 차이, 절대 URL, 상대 URL 등의 차이를 숨김 -> 캐싱 소프트웨어가 처리하기 쉽게 함
3. 검색
    - 로컬 복사본이 있는지 검사(from 메모리, 디스크, 근처 컴퓨터)하고, 사본이 없다면 사본을 받아옴 & 로컬에 저장
    - 캐시된 객체는 본문, 캐시 잔류 시간, 이용 횟수 등 메타데이터를 저장함
4. 신선도 검사
    - 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 질의
5. 응답 생성
    - 새로운 헤더와 캐시된 본문으로 응답 메시지 생성
    - 캐시된 응답을 원 서버에서 온 것처럼 만들기 위해 응답 헤더를 생성
    - HTTP 버전 변환 및 번역, 신선도 정보 삽입, via 헤더 컨트롤 등. 다만, Date 헤더 조정 불가
6. 발송
    - 응답 헤더가 준비되면 캐시는 응답을 전송함
    - 효율적 전달을 위한 노력 (ex. 커넥션 유지 등)
7. 로깅
    - 로그 파일과 캐시 사용 통계 갱신


## 사본을 신선하게 유지하기
1. 문서 만료
    - 만료되면 재검사 필요
    - 유효 기간 확인: `Cache-Control: max-age={시간}`, `Expires`
2. 서버 재검사
    - 만료 =/= 서버와 캐시의 데이터가 다름
3. 조건부 메서드와의 재검사
    - 조건부 GET: GET 요청 메시지에 If-로 시작하는 헤더를 추가
    - 서버와 캐시의 데이터가 다를 때만 응답을 받는 것 
4. If-Modified-Since: 날짜 재검사
    - IMS 요청
    - 요청: `If-Modified-Since: <date>`, 응답: `Last-Modified`
    - 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 응답을 받음
    - 몇몇 웹 서버는 날짜 비교 대신 문자열 비교를 하기 때문에, "정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면"이라는 의미로 사용되기도 함
    - 리소스가 주어진 날짜 이후로 변경됨: 요청 성공, 새 문서가 새로운 만료 날짜와 함께 캐시에 반환
    - 리소스가 주어진 날짜 이후로 변경되지 않음: 서버는 304 Not Modified 응답 메시지를 클라이언트에 돌려줌. 본문은 보내지 않지만 새로운 만료 날짜는 보내줌.
5. If-None-Match: 엔터티 태그 재검사
    - 날짜 검사의 문제점
        * 내용에는 변화가 없어도 변경 시각은 바뀔 수 있음
        * 철자나 주석 변경처럼 모든 캐시들이 다시 읽어들이기에는 사소한 변경일 수도 있음
        * 어떤 서버들은 최근 변경 일시를 정확하게 판별하지 못함
        * 1초보다 작은 간격으로 문서를 갱신하는 경우 1초가 충분하지 못한 정밀도가 될 수 있음 
    - If-None-Match 
        * 엔터티 태그(Etag, ex. v2.6)가 변경되었는지 검사
        * 변경된 경우 200 OK 응답과 새 Etag 반환
        * 변경되지 않은 경우 304 Not Modified 응답
        * 캐시가 여러 개의 사본을 갖고 있는 경우 여러 개의 Etag를 포함시킬 수 있다. (ex. If-None-Match: "v2.4", "v2.5", "v2.6")
6. 약한 검사기와 강한 검사기
    - 약한 검사기: (HTTP/1.1) 콘텐츠가 조금 변경되었더라도 "그 정도면 같은 것"이라고 주장할 수 있게 해줌
        * W/ 접두사: ex. Etag: W/"2.6"
    - 강한 검사기: 콘텐츠가 바뀔 때마다 바뀜. 강한 Etag 값을 재활용해서는 안 됨.
7. 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가
    - 서버가 엔터티 태그를 반환했다면 클라이언트는 엔터티 태그를 써야 함
    - 서버가 Last-Modified 값만 반환했다면 클라이언트는 if-Modified-Since 검사를 할 수 있음
    - 서버가 둘 다 반환했다면 클라이언트는 둘 다 사용해야 함 (HTTP/1.0과 HTTP/1.1 캐시 모두 지원하기 위함)
    - HTTP/1.1 원 서버는 엔터티 태그를 보내야 하고, Last-Modified 값을 같이 보낼 수도 있음
    - HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면, 두 가지 조건에 모두 부합할 때만 304 Not Modified 응답을 보낼 수 있음


## 캐시 제어
- 서버가 문서 만료 전까지 얼마나 오래 캐시될 수 있는지 설정
- 문서 만료는 완벽한 시스템이 아니다. 유효기간을 너무 길게 잡는 경우나, 유효기간을 사용조차 하지 않는 경우도 있다.
- 헤더 우선순위
    1. Cache-Control: no-store
        * 캐시가 응답의 사본을 만드는 것을 금지함
        * 캐시는 클라이언트에 no-store 응답을 전달하고 객체를 삭제함
    2. Cache-Control: no-cache
        * 실제로는 캐시 저장소에 저장될 수 있음
        * 서버와 재검사하기 전에는 캐시에서 클라이언트로 제공될 수 없음
        * cf. `Pragma: no-cache`: HTTP/1.0+와의 하위호환성
    3. Cache-Control: must-revalidate
        * 때때로 캐시는 성능을 위해 만료된 객체를 제공할 수 있음
        * 서버가 `Cache-Control: must-revalidate` 헤더를 보내면 캐시는 원 서버와의 재검사 없이 객체를 제공할 수 없음
        * 원 서버가 고장난 상태면 `504 Gateway Timeout error`
    4. Cache-Control: max-age
        * 문서가 서버로부터 온 이후 최대 유효 시간 (초 단위)
        * s-maxage 헤더는 공용 캐시에만 적용됨 
    5. Expires
        * 실제 만료 날짜 명시
        * 많은 서버가 부정확한 시계를 갖고 있기 때문에 절대시각 대신 경과된 시간으로 표현하는 것이 나음
        * 문서가 항상 만료되도록 Expires: 0과 같은 헤더를 보내는 것은 문법 위반임 
    6. 아무 만료 정보도 주지 않고 캐시가 스스로 결정
- 휴리스틱 만료
    * 응답에 `Cache-control: max-age` 헤더나 `Expires` 헤더 중 어느 것도 포함하지 않고 있는 경우
    * 경험적인 방법으로 최대 나이를 계산해서 Heuristic Expiration 경고 헤더를 응답에 추가함
    * 일반적으로는 1주일~하루 정도의 상한을 설정해 둠
    * 아무런 단서가 없을 때는 한 시간이나 하루 같은 기본 유지 기간을 설정하거나, 보수적으로 수명을 0으로 설정
- LM 인자 알고리즘
    * 문서가 최근 변경 일시를 포함하고 있을 때 사용
    * 마지막으로 변경된 것이 상당히 예전이라면, 잘 변하지 않는 안정적인 문서로 추측하고 더 오래 보관한다
    * 최근에 변경되었다면 자주 변경될 것으로 추측하고 짧은 기간 동안만 캐시한다
- 클라이언트 신선도 제약
    * 클라이언트는 `Cache-control` 헤더를 사용해 캐시 만료 제약을 엄격하게 또는 느슨하게 할 수 있다.
    * 엄격
        + 강제로 재검사하거나, 서버로부터 새로 가져온다. (ex. 수동 리프레시 버튼)
        + `Cache-Control: min-fresh = {s}` 만료 시간 이전 최소 s초의 여유 시간이 남아 있어야 한다.
        + `Cache-Control: max-age = {s}` s초보다 오래된 캐시된 문서를 반환할 수 없다. 
    * 느슨
        + 성능, 신뢰성, 비용 개선을 위해 느슨하게 검사한다.
        + `Cache-Control: max-stale = {s}` : 신선하지 않은 문서를 제공할 수 있다. 값이 있으면 s초 지난 것도 받아들인다.
        + `Cache-Control: only-if-cached`: 클라이언트는 캐시에 들어있는 사본만을 원한다.


## 캐시 제어 설정
- 아파치 서버가 캐시 제어를 지원하는 방법
- 아파치로 HTTP 헤더 제어하기
    * mod_headers: 개별 헤더 설정
    * mod_expires: Expires 헤더 자동 생성
    * mod_cern_meta: 제어하고자 하는 파일에 대응되는 메타파일들을 생성해줌 
- HTTP-EQUIV를 통한 HTML 캐시 제어
    * HTTP-EQUIV 태그: 문서의 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의함
    * 대부분의 웹 서버에서 지원하지 않음
    * 문제를 일으키기 때문에 대부분의 소프트웨어가 무시함
    * 캐시 제어를 위해서는 HTTP 헤더를 이용할 것


## 자세한 알고리즘
1. 나이와 신선도 수명 `(충분히 신선한가?) = (나이) < (신선도 수명)`
    - 나이: 서버가 문서를 보낸(or 마지막 재검사) 후 지난 시간. age 헤더 또는 date 헤더를 통해 판별함.
    - 신선도 수명: 아직 문서가 신선하다고 볼 수 있는 수명
    - 클라이언트의 요구사항 고려: ex. max-stale 헤더로 신선하지 않은 문서를 받아들이거나, min-fresh 헤더로 아직 신선한 문서도 안 받을 수 있음
2. 점층적 나이 계산
    ```
    (겉보기 나이) = max(0, (응답을 받은 시각) - (date 헤더값)
    (보정된 겉보기 나이) = max((겉보기 나이) - (age 헤더값))
    ```
    - 클록 스큐(clock skew): 두 컴퓨터의 시계 설정 차이로 인한 문제. 모든 컴퓨터 시계가 잘 동기화되지 않았기 때문임.
    - 클록 스큐 때문에 겉보기 나이는 종종 부정확하거나 음수가 될 수 있음
    - Age 헤더는 문서가 프록시나 캐시를 통과할 때마다 나이를 누적해서 더해줌
    - HTTP/1.1이 아닌 장치는 Age 헤더를 인식하지 못하기 때문에 헤더를 고치지 않거나 삭제할 수 있음. 따라서 Age 헤더 역시 추정값임.
    - 보정된 나이는 겉보기 나이와 age 중 큰 것이 선택됨
3. 네트워크 지연에 대한 보상
    ```
    (응답 지연 추정값) = (응답을 받은 시각) - (요청을 보낸 시각)
    (문서가 캐시에 도착했을 때의 나이) = (보정된 겉보기 나이) + (응답 지연 추정값)
    (사본이 캐시에 머무른 시간) = (현재 시각) - (응답을 받은 시각)
    (나이) = (문서가 캐시에 도착했을 때의 나이) + (사본이 캐시에 머무른 시간)
    ```
    - 문서가 프록시들과 부모 캐시의 긴 연쇄를 거쳐서 온 경우 네트워크 지연이 발생할 수 있다.
    - 서버에서 캐시로 오는 데 얼마만큼의 시간이 들었는지를 더하는 것은 측정이 어렵기 때문에, 넉넉히 캐시 -> 서버 -> 캐시의 왕복 시간을 더해 준다.
4. 완전한 나이 계산 `문서의 현재 나이 = (도착했을 때의 나이) + (문서가 캐시에 머무른 시간)`
5. 신선도 수명 계산: 클라이언트와 서버의 제약조건에 의존


## 캐시와 광고
1. 광고 회사
    - 장점
        * 네트워크 요금 감소
        * 같은 데이터를 몇 번이고 반복해서 보여줄 수 있음
        * 호화로운 기사나 광고를 빠르게 보여줄 수 있음 
    - 단점
        * 사용자들의 접근 횟수에 따라 돈을 버는데, 캐시를 거쳐 가면 원 서버에서는 실제 접근 횟수를 알 수 없게 됨
2. 퍼블리셔의 응답
    - 캐시과 광고 시청 수를 가로채지 못하도록 CGI 게이트웨이를 통해 광고 제공 (cf. CGI: 웹 서버에서 외부 프로그램 호출)
    - 매 접근마다 광고 URL이 변경되도록 함
    - 프록시 캐시뿐만 아니라 주로 브라우저 캐시를 대상으로 함
    - 장기적으로는 캐시가 트래픽을 흡수하되, 얼마나 적중이 일어났는지를 알려주는 방향으로 가야 함 ex. 모든 접근에 대한 재검사 -> 트랜잭션 느려짐
3. 로그 마이그레이션
    - 서버로 요청이 가지 않도록 해서 캐시가 모든 로그를 유지하도록 함
    - 보통 로그의 크기가 너무 크기 때문에 서버로 옮기기 어려움
    - 또한 로그를 콘텐츠 제공자별로 분리해서 보여주기도 어려움
4. 적중 측정과 사용량 제한
    - Meter 헤더: 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려줌
    - 사용량 제한: 서버는 캐시가 문서를 제공할 수 있는 횟수나 소모할 수 있는 처리 시간을 제한할 수 있음