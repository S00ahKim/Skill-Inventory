# Overview
참고: HTTP 완벽 가이드 I-01 (웹의 기초 > HTTP 개관)

- HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용함
- HTTP(애플리케이션 계층 프로토콜) - TCP(전송 계층 프로토콜) - IP(네트워크 계층 프로토콜)
     * 특징: 오류 없음, 손상 또는 손실 없음, 순서 유지, 크기 무관
     * by... IP 주소(DNS로 호스트 이름에서 변환) + 포트 번호(기본값 80)
- 단순함, 확장 가능

## 클라이언트-서버 구조
- 웹 클라이언트는 데이터를 요청하고, 웹 서버는 요청된 데이터를 응답한다.
    * 가장 대표적인 웹 클라이언트는 웹 브라우저
- 각각 독립적으로 개발할 수 있다는 장점
- 트랜잭션은 요청과 응답으로 구성
    * 메서드, 상태 코드, 메시지(요청, 응답 / 시작줄-헤더-본문(opt.))
    * 웹페이지는 보통 하나의 리소스가 아닌 리소스의 모음. 많은 트랜잭션을 필요로 함.

## stateless (무상태)
- 응답하는 서버가 중간에 바뀌어도 무관하다
- 무상태는 응답 서버를 쉽게 바꿀 수 있다 (=무한 서버 증식 가능)
- 모든 것을 무상태로 설계하기 어려울 수 있다: 로그인 유지 등
    * 쿠키, 세션 등 활용
    * 최소한으로 유지

## 비연결성
- HTTP는 기본적으로 연결을 유지하지 않는다
    * tcp/ip는 연결을 유지한다. 클라이언트가 요청을 보내지 않아도 유지하므로, 자원이 소모된다.
    * 클라이언트가 수만 대에 육박하면 연결을 유지하기 부담스럽다. 일반적으로 웹서비스는 동시 처리 요청수가 작으므로 연결을 유지하지 않아도 괜찮다.
- 한계와 극복
    * tcp/ip 연결은 새로 맺어야 한다 (3 way handshake 비용)
    * html 외에도 크기가 큰 리소스들(이미지 등)이 함께 다운로드된다
    * HTTP 지속 연결(필요한 것을 다 받을 때까지는 연결 유지)로 문제를 해결했다
    * HTTP 버전이 올라가면서 더 많이 최적화되고 있다 (ex. 3는 udp로 연결 맺는 속도도 줄임)

## 리소스
- 리소스는 콘텐츠. 정적 콘텐츠, 동적 콘텐츠 모두를 말함.
     * 정적: 늘 같은 응답
     * 동적: 어떤 요청이냐에 따라 다르게 응답
- URI는 리소스 식별자
- URL은 리소스의 구체적인 위치 (스킴(프로토콜)+주소+리소스)
- URN은 위치에 영향 받지 않는 이름

## HTTP 메시지로 통신
- 각종 리소스를 HTTP 메시지에 담을 수 있음
- 다루는 데이터 타입이 많기 때문에 전송 객체에는 MIME 타입이라는 라벨링
     * ex. `Content-type: image/jpeg` (주타입/부타입)

## HTTP 버전 변화
- 0.9 (프로토타입, GET만 지원)
- 1.0 (메서드, 멀티미디어 처리 등 널리 쓰이는 관례 모음)
- 1.0+ (keep-alive connection, 가상 호스팅 지원, 프록시 연결 지원 등 사실상의 표준)
- 1.1 (구조 개선, 성능 최적화 등 표준)
- 2.0 (성능 & 속도 개선, SPDY 프로토콜 기반으로 설계)
     * SPDY는 HTTP의 데이터 전송 포맷과 커넥션 관리 부분을 고쳐서 TCP 커넥션을 보다 효율적으로 쓰도록 만든 것 [참고](https://d2.naver.com/helloworld/140351)
     * HTTP1.1의 문제? 동시전송 문제 & 다수의 리소스를 처리하기에 속도와 성능 이슈 ex.HOL(Head Of Line) Blocking-특정응답지연, RTT(Round Trip TIme) 증가, 헤비한 Header 구조
     * 기존의 해결 과정? 이미지 스프라이트, 도메인샤딩, CSS/JavaScript 압축, Data URI 등
     * HTTP2.0의 특징? [참고](https://medium.com/@shlee1353/http1-1-vs-http2-0-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EA%B0%84%EB%8B%A8%ED%9E%88-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-5727b7499b78)
            1. Multiplexed Streams(한 커넥션에 여러개의 메세지를 동시에 주고 받을 수 있음)
            2. Stream Prioritization(요청 리소스간 의존관계를 설정)
            3. Server Push(HTML 문서 상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 있음)
            4. Header Compression(Header 정보를 HPACK 압축 방식을 이용하여 압축 전송)
     * [구글의 소개 문서](https://developers.google.com/web/fundamentals/performance/http2?hl=ko)

## 다양한 웹 애플리케이션 형태
1. `프록시`는 클라이언트와 서버 사이에 위치한 HTTP 중개자다.
     * 신뢰할 수 있는 중개자
     * 클라이언트의 요청을 (대개 수정하여) 서버에 전달함
     * 주로 보안을 위해 사용 ex. 바이러스 검출, 성인 콘텐츠 차단
2. `캐시`는 많이 찾는 웹페이지를 클라이언트 가까이 보관하는 HTTP 창고다.
     * 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장함 
3. `게이트웨이`는 다른 애플리케이션과 연결된 특별한 웹 서버다.
     * 다른 서버들의 중개자
           * 프록시와의 차이? 일종의 프록시, 주된 역할의 차이, 스스로 리소스를 가지는 진짜 서버인 것처럼 요청을 다룸
     * 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용됨 
4. `터널`은 단순히 HTTP 통신을 전달하기만 하는 특별한 프록시다.
     * 두 커넥션 사이에서 데이터를 열어보지 않고 전달함
     * 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결에 그대로 전송하기 위해 사용됨 ex. `SSL --(터널: HTTP 연결)--> SSL`
5. `에어전트`는 자동화된 HTTP 요청을 만드는 준지능적 웹 클라이언트다.
     * 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램 ex. 웹 브라우저, 웹로봇/스파이더 