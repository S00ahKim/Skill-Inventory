# Connection Management

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP 최적화
- 커넥션 관리를 위해 따라야 할 규칙들


## TCP 커넥션
- 모든 http 통신은 tcp/ip를 통해 이루어짐
- TCP는 신뢰할 수 있음. 브라우저가 주소를 찾아 커넥션을 생성하고, 커넥션이 맺어지면 tcp의 특성상 메시지가 손실/손상되지 않고 순서가 바뀌지 않음
- TCP는 세그먼트라는 단위로 데이터 스트림을 나누고, 세그먼트를 IP 패킷에 담아 전달함 by TCP/IP 소프트웨어
    * IP 패킷 구성 요소
        1. IP 패킷 헤더 (발신지, 목적지 IP 주소, 크기, 기타 플래그)
        2. TCP 세그먼트 헤더 (TCP 포트 번호, TCP 제어 플래그, 데이터 순서, 무결성 검사용 숫자 값)
        3. TCP 데이터 조각
- TCP 커넥션은 발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트 의 값으로 식별 가능한 유일한 커넥션을 만든다.
- OS 단에서 TCP 커넥션 생성을 위한 기능을 제공함. 소켓 API는 TCP/IP의 세부 구현을 숨긴다.
    * 소켓 API의 역할: 데이터 구조 연결, 데이터 스트림 읽고 쓰기 
        1. bind: 소켓에 로컬 포트와 인터페이스 할당
        2. listen: 소켓 커넥션을 허가함
        3. accept: 커넥션을 맺기를 기다림
    * TCP API의 역할: 핸드셰이킹, ip 패킷 분할 및 재조립 등
    * 소켓이란 네트워크 환경과 연결할 수 있도록 만들어진 연결 부분을 말함
    * 웹소켓과는 다르다!!
        1. 웹 소켓은 HTTP 커넥션으로 핸드셰이킹하고, utf-8 포맷의 데이터를 주고받는다.
        2. TCP 소켓은 TCP 커넥션으로 핸드셰이킹하고, 바이트 스트림을 사용한다.

### (+a) 웹소켓이란?
- 무엇인가? 서버-클라이언트 사이에 연결이 계속 유지될 수 있도록 소켓 연결을 할 수 있게 하여 full-duplex를 지원하는 통신 규약
- 왜?
    * connectionless한 HTTP의 특징 때문에 실시간 상호작용성이 떨어지는 것을 보완하기 위해
    * ActiveX를 쓰지 않기 위해... (ActiveX는 서버에 요청을 보내고도 페이지를 이동하지 않을 수 있게 하기 위한 일종의 꼼수)
    * 실시간 게임, 인스턴트 소셜 네트워크 알림, 주식, 또는 날씨 정보의 최신 디스플레이 등 안전하고 빠른 데이터 전송이 필요한 앱에 사용하는 데 적합
- 특징?
    * 클라이언트와의 연결이 유지되므로 클라이언트의 상태를 알 수 있다
    * http 요청을 사용하므로 기존 포트(80, 443)를 접속하여 방화벽 처리 불필요 + CORS, 인증 등 과정에서 추가 설정 불필요
    * 기본 자바스크립트 웹소켓 API는 간단한 기능만 제공하여 socket.io와 같은 오픈소스를 사용하는 경우가 많음
    * HTML5에 정식으로 포함되었음
- 기존에는?
    1. polling: 클라이언트가 http request를 서버로 계속 날려 이벤트 내용을 전달받음
          * 가장 쉬운 방법
          * 서버의 부담이 많아짐
          * 실시간이라고 할 만큼의 빠른 응답을 기대하기 어려움 
    2. long polling: 클라이언트가 전달한 http request를 응답이 생길 때만 서버가 응답함
          * 서버는 일단 요청하고 응답을 지연하고, 클라이언트는 응답을 받으면 곧바로 다시 요청함
          * 이 주기가 짧으면 일반적인 polling과 차이가 없어짐
    3. streaming: 클라이언트가 http request를 보내면 서버는 응답을 끊임없이 흘려보냄
          * long polling처럼 응답을 끊는 게 아니라 하나의 연결에서 계속 보내는 것
          * 하나의 tcp 포트로 읽기와 쓰기를 동시에 할 수 없기 때문에 메시지 입력은 tcp 외의 포트에서 받아야 함
    + 2번과 3번 방법은 http comet이라고도 불림
    + 웹소켓이 기존의 방법과 다른 것은...
          1. full-duplex를 지원
          2. tcp 소켓을 쓰는 게 아님
          3. stateful (같은 연결을 계속 쓰니까 연결을 위해 사용하는 불필요한 데이터 전송을 막을 수 있음)
- 어떻게?
    1. http 프로토콜의 handshake 과정으로 웹소켓을 사용할 수 있는지 확인
    2. 성공할 경우 http를 웹소켓 프로토콜로 바꿈
    3. 만들어진 새로운 소켓으로 통신함 (ws-일반 웹소켓/wss-ssl적용된 웹소켓)
- 이슈
    * stateful한 만큼 서버와 클라이언트 연결을 계속 유지해야하고, 비정상적 연결이 끊어졌을 때를 대응해야함.
    * 서버와 클라이언트간의 socket 연결을 하는 것 자체가 비용이 많이 든다 (트래픽이 많은 서버 같은 경우 CPU부담이 될 수 있다)
- [참고](https://medium.com/@icehongssii/%EA%B9%9C%EC%B0%8D%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%83%81%EC%8B%9D-2-2-http%EB%A5%BC-%EB%84%98%EC%96%B4%EC%84%9C-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9websocket-c49125e1b5a0)와 [참고2](https://medium.com/@chullino/http%EC%97%90%EC%84%9C%EB%B6%80%ED%84%B0-websocket%EA%B9%8C%EC%A7%80-94df91988788)

## TCP의 성능
- HTTP의 성능은 TCP의 성능에 영향을 받는다. 너무 많은 데이터를 받아오려고 하거나, 복잡하고 동적인 리소스를 실행하지 않는 한.
    * DNS에서 호스트 이름을 IP 주소로 바꾸는 데 걸리는 시간 -> 현재는 이런 경우가 적고, 대부분 DNS 캐시를 사용
    * 새로운 커넥션을 맺는 데 걸리는 시간 -> 마찬가지로 현재는 이런 경우가 적음
    * 클라이언트에서 서버까지 메시지가 전달되고 처리되는 데 걸리는 시간
    * 서버가 클라이언트에게 응답을 보내는 데 걸리는 시간
    * 그 외 TCP 네트워크 지연 원인 후보: 하드웨어 성능, 네트워크/서버 전송 속도, 메시지 크기, 클라이언트와 서버의 거리
- 성능 관련 중요 요소
    1. TCP 커넥션의 핸드셰이크 설정
        * 문제: 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP 구성에 사용함
        * 해결: (이후 챕터에서 다룸) 이미 존재하는 커넥션 재활용
    2. 인터넷 혼잡 제어를 위한 TCP의 slow start
        * 문제: TCP 커넥션은 처음에는 최대 속도에 제한이 있고, 전송이 성공할수록 속도가 빨라진다. (급작스러운 부하, 혼잡을 막기 위함)
        * 해결: 어느 정도 데이터를 주고받은 튜닝된 커넥션을 재활용
    3. 데이터를 한데 모아 한번에 전송하고자 하는 네이글 알고리즘
        * 문제: 효율적(헤더 양>>데이터 양 방지)인 데이터 전송을 위해 많은 데이터를 합쳐 전송하는 네이글 알고리즘. 버퍼에서 대기하며 지연 발생함. 특히 확인응답 지연과 함께 쓰이면 양쪽에서 지연되니까 형편없어짐.
            + Silly Window Syndrome 전송자: 1바이트 크기 패킷을 대량 전송하는 것. 다른 인터넷 통신에 방해가 됨. 
        * 해결: HTTP 애플리케이션에서 HTTP 스택에 TCP_NODELAY 파라미터 값 설정하여 네이글 알고리즘 비활성화 가능. 하지만 작은 패킷이 너무 많이 생기지 않도록 주의해야 함.
    4. TCP의 편승(piggyback) 확인 응답(ack)을 위한 확인응답 지연 알고리즘
        * 문제: ack와 송출 데이터를 묶어 보내기 위해 잠시 ack를 지연시킴
        * 해결: 지연의 원인이 되는 관련 기능을 수정/비활성화 가능. 하지만 수정할 때에는 그 수정이 tcp 내부 알고리즘이 피하려는 문제를 발생시키지 않을 것임을 확신할 수 있어야 함. 
    5. TIME_WAIT 누적으로 인한 지연과 포트 고갈
        * 문제: 실제 상황에서는 큰 문제가 아닌데 문제 상황으로 오해할 수 있음
            + TIME_WAIT은 TCP 상태의 가장 마지막 단계. 
                + 이전 커넥션과 새로운 커넥션이 충돌하는 것을 방지하기 위함
                + 먼저 close()를 요청한 곳에 최종적으로 남음
                + 같은 주소+포트번호의 TCP 커넥션을 일정 시간(2MSL) 동안 생성하지 못하게 함
            + 성능 테스트 환경에서는 열린 서버도 별로 없는데 테스트하는 클라이언트도 별로 없으니 유일할 수 있는 조합(클라주소, 서버주소, 목적지포트=80, 발신지포트=`changeable`)이 적은데 TIME_WAIT 때문에 재활용도 어려움. 그러면 사용 가능한 발신지 포트가 약 6만 개고, 2MSL을 120초로 가정할 경우 초당 500개로 커넥션이 제한됨. 서버가 초당 500개 이상의 트랜잭션을 처리할 만큼 성능이 좋으면 TIME_WAIT 포트 고갈이 발생할 수 있는 것.
            + 현재는 라우터가 빨라져서 커넥션이 닫혔는데 중복되는 패킷이 생기는 경우는 거의 없어졌음. 그럼에도 2MSL을 수정하는 것은 조심해야 함.
        * 해결: 부하를 생성하는 클라이언트 역할의 장비를 더 많이 사용하거나, 더 많은 커넥션을 맺을 수 있도록 여러 개의 가상 IP 주소를 사용
            + 포트 고갈 문제를 겪지 않더라도, OS에 따라 성능 문제를 겪을 수 있으므로 커넥션을 너무 많이 맺거나 대기 상태의 control block을 너무 많아지지 않도록 주의
        * [참고: TIME_WAIT 상태란 무엇인가](http://docs.likejazz.com/time-wait/)

## HTTP 커넥션 관리