# 기본 핵심 원리
- [기본 핵심 원리](#기본-핵심-원리)
  - [객체 지향 프로그래밍](#객체-지향-프로그래밍)
    - [SOLID](#solid)
  - [객체 지향 원리 적용](#객체-지향-원리-적용)
    - [DI 컨테이너](#di-컨테이너)
    - [OCP, DIP 위반 사례를 개선하기](#ocp-dip-위반-사례를-개선하기)
    - [관심사 분리](#관심사-분리)
    - [의존 관계의 종류](#의존-관계의-종류)
    - [IoC 컨테이너 또는 DI 컨테이너](#ioc-컨테이너-또는-di-컨테이너)
    - [스프링으로 바꾸기](#스프링으로-바꾸기)
  - [스프링 컨테이너와 스프링 빈](#스프링-컨테이너와-스프링-빈)
    - [스프링 컨테이너 생성 과정](#스프링-컨테이너-생성-과정)
  - [싱글톤 컨테이너](#싱글톤-컨테이너)
    - [싱글톤 패턴](#싱글톤-패턴)
    - [싱글톤 컨테이너](#싱글톤-컨테이너-1)
    - [주의!!](#주의)
  - [빈을 자동으로 등록하고 사용하기](#빈을-자동으로-등록하고-사용하기)
    - [컴포넌트 스캔](#컴포넌트-스캔)
    - [의존관계 자동 주입](#의존관계-자동-주입)
      - [롬복(lombok)](#롬복lombok)
      - [조회하는 빈이 2개 이상이다?](#조회하는-빈이-2개-이상이다)
  - [빈 생명주기 콜백](#빈-생명주기-콜백)
    - [생명주기 콜백 지원 방법](#생명주기-콜백-지원-방법)


## 객체 지향 프로그래밍
> 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
- 스프링 = SOLID, 다형성 극대화, 단점 보완 by IoC, DI
- 좋은? `추상화`, `캡슐화`, `상속`, `다형성`이라는 특징을 잘 살림
    * 최중요 개념 **다형성** / 객체의 관계 = **협력**
    * `역할`과 `구현` 분리: 인터페이스와 구현 객체, 설계시 역할 먼저 부여
- 프로그램을 유연하고 변경이 용이하게 만든다 (실행 시점에 구현 변경 가능)

### SOLID
- 단일 책임 원칙: 하나의 책임만 갖게 할 것. (변경의 파급이 적음)
- 개방 폐쇄 원칙: 확장에 열려 있고 변경에 닫혀 있음.
    * 하지만 다형성을 사용해도 이를 지키기 어려움. 
    * 해결: [객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자를 도입](#ocp-dip-위반-사례를-개선하기)
- 리스코프 치환 원칙: 하위 타입 인스턴스로 교체 가능함을 기능적으로 보장 (의미에 맞게, 규약 준수)
- 인터페이스 분리 원칙: 범용 인터페이스 하나보다 특정 클라이언트를 위한 구체적 인터페이스 여러개
    * 이상적으로는 모든 설계에 인터페이스를 부여하는 게 좋음
    * 그러나 인터페이스는 추상화 비용이 있음 (성능 X, 개발 과정에서의 비용)
    * 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법
- 의존 관계 역전 원칙: 구현 클래스에 의존하지 말고, 인터페이스(역할)에 의존
    * 다형성을 사용해도 인터페이스에 의존하면서 구현 클래스에도 의존하는 등 DIP를 지키기 어려움


## 객체 지향 원리 적용
### DI 컨테이너
- 스프링은 DI 컨테이너로 다형성 + OCP, DIP 가능하게 지원
- 순수 자바 코드로 OCP, DIP를 준수하려니 할 게 많아서 아예 프레임워크화한 것

### OCP, DIP 위반 사례를 개선하기
```java
// new로 구현체를 의존하던 부분을 인터페이스에만 의존하도록 설계를 변경
private MemberRepository memberRepository;

// 별다른 설정이 없으면 NPE 발생 -> 어디선가 구현체를 생성&주입해주어야 함
// AppConfig.java
public MemberService memberService() {
  return new MemberServiceImpl(memoryMemberRepository());
}

public MemoryMemberRepository memoryMemberRepository() {
  return new MemoryMemberRepository()
}

// MemberServiceImpl.java
private final MemberRepository memberRepository;

public MemberServiceImpl(MemberRepository memberRepository) {
  this.memberRepository = memberRepository;
  // 여기에 MemoryMemberRepository의 인스턴스가 들어옴
  // 생성자로 주입되고 있으므로, <생성자 주입>이라고 부른다
}
```

### 관심사 분리
- 구현 객체를 생성하고 연결하는 책임을 다른 곳에서 하게 하자
- `사용 영역`과 `구성 영역`으로 분리되었다.
    + 사용 영역: 앱의 실제 동작에 필요한 구현 객체를 생성 & 생성한 객체 인스턴스의 참조값(레퍼런스)을 생성자로 주입 (ex. `AppConfig`)
    + 구성 영역: 로직 실행 (ex. `MemberServiceImpl`)
- 이제 구현체는 자기가 사용하는 구현체를 모른다. 구체적인 프로그램 실행 방법을 모른다. 흐름 제어는 모두 AppConfig의 역할이다.

### 의존 관계의 종류
1. 정적인 클래스 의존관계
    - import 문에 의한 의존 관계
    - 애플리케이션 실행 없이 분석 가능
2. 동적인 객체 인스턴스 의존 관계
    - 애플리케이션 실행 시점(런타임)에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계
- 의존관계 주입을 사용하면...
    * 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
    * 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.

### IoC 컨테이너 또는 DI 컨테이너
> AppConfig.java
- 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것
- 최근에는 보통 DI 컨테이너라 한다. (or 어셈블러 / 오브젝트 팩토리 등)
- AppConfig를 보면 애플리케이션의 전체 구성을 빠르게 파악할 수 있다.
- 구현체가 변경되면 AppConfig만 변경하면 된다. (중복 코드 적음, 변경 간편)

### 스프링으로 바꾸기
- AppConfig에 `@Configuration`을 붙이고, 그 안의 메소드들에 `@Bean` 붙이기
    * 스프링 컨테이너는 @Configuration 이 붙은 AppConfig 를 설정(구성) 정보로 사용
    * 여기서 @Bean이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록
    * @Bean이 붙은 메서드의 이름을 스프링 빈의 이름으로 사용
- 그러면 **스프링 컨테이너**에 빈이 등록된다.
    * = 애플리케이션 콘텍스트
    * 이 친구가 모든 빈을 관리한다.
- 스프링을 사용하지 않을 경우...
    * 직접 객체 생성 및 등록
    * 직접 필요한 객체 조회
    * 모든 과정을 자바 코드로 조작
- 스프링을 사용할 경우...
    * 스프링 컨테이너를 통해 객체 생성, 등록, 조회
    * 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경


## 스프링 컨테이너와 스프링 빈
- ApplicationContext는 인터페이스로, 다형성으로 구현체로 생성
- 스프링 컨테이너는 엄밀하게는 BeanFactory, ApplicationContext으로 구분되나 전자를 직접 사용하는 경우가 드물어 후자를 보통 스프링 컨테이너라고 부른다.
    ```
    BeanFactory(인터페이스) <- ApplicationContext(인터페이스) <- 구현체 (ex. AnnotationConfigApplicationContext)
    ```
    * BeanFactory는 스프링 빈을 관리하고 조회하는 역할을 갖는다.
    * ApplicationContext는 `B.F`. + `애플리케이션을 위한 각종 부가기능`(국제화, 환경변수, 이벤트, 리소스 조회 등)
    * 구현체는 설정 형식에 따라 다르다. 자바 코드면 AnnotationConfigApplicationContext, xml이면 GenericXmlApplicationContext, ... 이런 식. (최근에는 거의 자바 코드 기반)
- 다양한 설정 형식(어노테이션/xml 등)을 지원할 수 있는 이유는 BeanDefinition 이라는 추상화가 있기 때문이다.
    * (무슨 형식이든 간에) 설정을 읽어서 **BeanDefinition을 만드는 것**이 스프링 컨테이너가 할 일!
        + ex. AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader를 사용해서 AppConfig.class를 읽고 BeanDefinition을 생성한다.
        + 직접 생성하는 것도 가능은 하지만, 실무에서 그럴 일은 거의 없다.
    * BeanDefinition
        + 빈 하나마다 하나씩 생성됨
        + 이 친구도 인터페이스라서 스프링 컨테이너는 추상에만 의존하게 됨
        + 빈 설정 메타정보 : 팩토리 빈 이름, 빈을 생성할 팩토리 메서드 등등

### 스프링 컨테이너 생성 과정
1. 스프링 컨테이너 생성
    ```java
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class)
    ``` 
    * 스프링 컨테이너에 정보 제공
    * 스프링 컨테이너 안에는 스프링 빈 저장소가 있음
2. 스프링 빈 등록
    * @Bean 붙은 거 죄다 호출해서, 스프링 빈 저장소에 메소드 이름을 key로, value를 빈 객체로 등록
    * (참고로 스프링 내부 실행을 위한 빈도 등록됨)
    * 설정에 따라 다르지만 빈 이름을 항상 유니크하게 만들 것
3. 스프링 빈 의존관계 설정
    * 설정 정보를 참고해서 의존관계를 주입함
    * 단순히 코드 호출이 되는 정도가 아니라, [싱글톤](#싱글톤-컨테이너)을 보장한다.
    * 어노테이션(자바 코드)으로 빈을 등록하면 2와 3이 한번에 실행된다.


## 싱글톤 컨테이너
- 스프링은 기본적으로 웹앱을 위한 기술이다.
- 웹앱에서는 보통 여러 사용자가 동시에 요청한다. 그때마다 객체 생성을 한다면 비효율적이다.

### 싱글톤 패턴
> 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 방법?
    * static 영역에 객체 instance를 미리 하나 생성해서 올리고
    * 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회하며
    * 새로운 인스턴스가 만들어지지 않도록 생성자를 private으로 지정
- 장점: 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다
- 단점: 코드량이 많고, 구현체에 의존하여 DIP를 위반하고, OCP를 위반할 가능성이 높음. 테스트도 어렵고 유연성이 떨어짐.

### 싱글톤 컨테이너
> = 스프링 컨테이너 <br/>
> 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 함 & **싱글톤 레지스트리로써 빈이 1개만 생성되게 강제**함
- 지저분한 코드와 getInstance() 등을 모두 스프링이 알아서 해줘서 싱글톤 패턴 없이 싱글톤으로 관리 가능
- 기본 빈 등록 방식이 싱글톤이긴 하지만, 요청할 때 마다 새로운 객체를 생성해서 반환하는 [기능]()도 제공한다
- `@Configuration`
    * 빈을 만드는 코드에서 인스턴스 생성하는 게 겹치는 것 같이 보일 수 있다.
    * 그러나 확인해보면 모두 같은 인스턴스를 공유하고 있다. (생성 코드 호출 자체가 1회만 일어남)
    * 스프링이 **클래스 바이트코드를 조작**하는 라이브러리 CGLIB를 사용하기 때문에 이와 같은 현상이 가능하다.
    * 즉, AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, **그 다른 클래스를 스프링 빈으로 등록**한 것!
    * 임의의 다른 클래스 안에는 생성 코드가 호출될 때마다 **스프링 컨테이너에서 우선 찾아보는** 과정을 거치는 로직이 포함
    * @Configuration 을 적용하지 않고, @Bean 만 적용하면 CGLIB의 적용 대상이 아니라 매번 새 인스턴스가 생성된다! 즉, 스프링 빈으로 등록은 되지만, 싱글톤을 보장하지 않는다. 설정 정보를 빈으로 등록할 땐 꼭 붙이자.

### 주의!!
- 무상태로 설계해야 한다
- 특정 클라이언트에 의존적이거나, 값을 변경할 수 있는 필드가 있으면 안 된다.
- 가급적 읽기 전용이어야 하며, 필드 대신 자바에서 공유되지 않는 지역변수/파라미터/ThreadLocal을 사용해야 한다.
- 상태를 갖게 설계할 경우 벌어질 수 있는 일 (ex. 로그인했는데 다른 사람 정보가 뜬다)


## 빈을 자동으로 등록하고 사용하기
- 수십개에 달하는 빈을 수동 등록하기는 어렵다. 스프링은 컴포넌트 스캔과 @Autowired를 지원한다.
- 비즈니스 로직 빈의 경우 기본으로 자동 등록을 사용하고, 기술 지원을 위한 빈의 경우 필요하면 수동을 사용하자.
    * 기술 지원은 문제 위치를 파악하기가 비교적 어렵고, 패턴화되어있지 않은 경우가 많음. 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다.
    * 비즈니스 로직의 경우에는 다형성을 적극 활용하는 경우, 자동 등록을 하면 다른 사람이 파악하기 어려울 수 있으니 별도의 설정 정보로 만들고 수동으로 등록하면 좋다. (Map/List로 받기보다)
    * 단, 스프링과 스프링 부트가 자동으로 등록하는 수 많은 빈들은 꼭 의도대로 사용하자.

### 컴포넌트 스캔
> `@ComponentScan`을 설정 정보에 붙이면 수동으로 설정 정보를 작성하지 않아도 자동으로 **스프링 빈으로 등록**해줌
- basePackages 등으로 지정하지 않으면 @ComponentScan 이 붙은 설정 정보 클래스의 패키지가 스캔 시작 위치
- 스프링 부트 디폴트? 패키지 위치를 지정하지 않고, 설정 정보 클래스(`@SpringBootApplication`를 붙여서 표기, 이 안에 @ComponentScan이 들어있음)의 위치를 프로젝트 최상단에 둠
- 동작 원리
    1. `@Component` 애노테이션이 붙은 모든 클래스를 스프링 빈으로 등록
        + @Component 가 붙어있거나, 안에 붙어있는 애노테이션(ex. @Controlller)을 단 클래스가 대상
        + 빈 이름은 맨 앞글자가 소문자인 클래스명
        + 직접 지정을 원할 경우 `@Component("memberService2")`
        + 중복?
            * 자동 vs 자동 => ConflictingBeanDefinitionException 발생
            * 자동 vs 수동 => 수동이 우선 (오버라이드) / 실수 생기기 좋아서 최근 부트는 기본적으로 에러나게 바뀜
    2. 생성자에 `@Autowired`를 붙여 두면 스프링 컨테이너가 자동으로 해당 빈을 찾아 주입
        + 기본적으로는 타입으로 찾음
        + 생성자가 파라미터가 많아도 다 찾아줌
- cf. 애노테이션 상속? 상속 관계는 따로 없으며, 애노테이션 안에 그냥 포함하는 것. 스프링이 지원하는 기능.
- 사용할 일이 많지는 않지만, 컴포넌트 스캔 대상을 추가로 지정(includeFilters)하거나 제외할 대상을 지정(excludeFilters)할 수 있다. 지정하는 방법은 어노테이션/타입/정규식/AspectJ패턴/인터페이스 커스텀 등이 있다.

### 의존관계 자동 주입
> 컴포넌트 스캔이 빈으로 등록만 해주기 때문에 `@Autowired`로 **의존관계 주입**을 자동으로 해줌
1. **생성자 주입**
    - **생성자 호출시점에 딱 1번만 호출됨**: 컴포넌트 스캔을 할 때, 빈 등록을 하려면 생성자 호출을 하고, 그때 @Autowired가 붙어있으면 스프링 컨테이너에서 스프링 빈을 꺼내기 때문에 자연스럽게 주입이 된다.
    - 불변, 필수 의존관계에 사용
    - 스프링 빈의 경우, 생성자가 딱 1개면 @Autowired를 생략해도 자동 주입됨
    - 권장되는 방법
        * 대부분 불변, 필수 의존관계임
        * 스프링 프레임워크 없이 가볍게 테스트하기 좋음 
        * 의존관계 누락시 컴파일 시점에 에러 (필드를 final로 지정)
2. 수정자 주입(setter 주입)
    - setDependency() 와 같은 수정자 메서드에 @Autowired를 붙임
    - 선택, 변경 가능성이 있는 의존관계에 사용
    - public으로 setter를 열어둬야 해서 의도치 않은 변경이 있을 수 있음 (나쁜 설계)
    - 주입할 대상이 없을 수 있다면 `@Autowired(required=false)`/세터 파라미터에 `@Nullable`/세터 타입을 `Optional<Type>`
3. 필드 주입
    - @Autowired private MemberService memberservice; 와 같이 필드 앞에 붙임
    - 간단하지만, 외부에서 변경할 수 없다는 한계(@SpringBootTest가 붙은 테스트 코드/Configuration에선 괜찮음)
4. 일반 메서드 주입
    - 2번과 비슷하지만 setter가 아니라 일반 메서드에 붙임. 이 경우 한번에 여러 의존관계 주입이 가능.
    - 잘 사용되지 않음

#### 롬복(lombok)
- 롬복 라이브러리가 제공하는 `@RequiredArgsConstructor` 기능을 사용하면 final이 붙은 필드를 모아서
생성자를 자동으로 만들어준다
- `by` 자바의 애노테이션 프로세서 기능을 이용
- `how` 컴파일 시점에 생성자 코드를 자동으로 생성

#### 조회하는 빈이 2개 이상이다?
- 기본적으로 타입으로 조회하기 때문에 해당되는 빈이 2개 이상일 수 있다 => NoUniqueBeanDefinitionException
- 해결?
    * ~~하위 타입으로 지정~~
        + DIP를 위배
        + 유연성이 떨어짐
        + 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결 불가
    * 스프링 빈을 수동 등록
    * @Autowired 필드 명 매칭
        + 필드 명을 빈 이름으로 변경
        + 스프링은 타입 매칭을 먼저 시도하고, 여러 빈이 있으면 추가로 필드명 매칭을 시도함
    * @Qualifier끼리 매칭 (빈 이름 매칭)
        + `@Qualifier("mainDiscountPolicy")`처럼 아예 붙여줌
        + 주입받는 곳에서 @Qualifier를 전부 붙여줘야 해서 번거로움
    * @Primary 사용
        + 우선 순위를 부여할 곳에 붙여줌
        + 주로 적용할 빈과 가끔 적용할 빈을 구분하기 위해 가끔인 경우에만 @Qualifier를 사용하는 방법이 있음. @Qualifier가 더 상세한 범위에 대한 적용이기 때문에 @Primary에 앞서기 때문임.
- 정말 필요해서 조회했다면... (ex. [전략 패턴](../DesignPattern/StrategyPattern.md)의 구현을 위해)
    * `Map<String, Type>` 빈 이름이 키, 해당 타입으로 조회한 빈이 값
    * `List<Type>` 타입으로 조회한 빈들 리스트
    * 조건에 따라 특정 빈을 선택하고 싶은 경우에 사용


## 빈 생명주기 콜백
> 빈이 생성&초기화될 때, 삭제될 때 콜백을 호출
- 언제 활용? 객체의 초기화와 안전하게 정상 종료 작업이 필요한 경우
    * DB 커넥션 풀
    * 네트워크 소켓 (앱 시작 때 연결 미리 해두고, 앱 종료 때 모두 종료)
- 스프링 빈 라이프사이클: `객체 생성` -> `의존관계 주입`
- 스프링 빈 이벤트 라이프사이클: `스프링 컨테이너 생성` -> `스프링 빈 생성` -> `의존관계 주입` -> `초기화 콜백` -> `사용` -> `소멸 전 콜백` `스프링 종료`
    * 빈이 생성되고 의존관계 주입이 완료되면 콜백 호출
    * 빈이 소멸되기 직전에 콜백 호출
- 객체의 생성과 초기화 분리 (초기화 작업이 단순하지 않고 보다 무거운 동작`ex.커넥션 연결`을 수행할 경우)

### 생명주기 콜백 지원 방법
1. 인터페이스(InitializingBean, DisposableBean)
    * 각 인터페이스를 받아서 afterPropertiesSet() 메서드, destroy() 메서드를 구현
    * 스프링 전용 인터페이스에 의존하며, 메서드 이름 변경 불가(-> 외부 라이브러리 적용 불가)
    * 거의 사용하지 않는 초창기의 방식
2. 설정 정보에 초기화 메서드, 종료 메서드 지정
    * @Bean(initMethod = "init", destroyMethod = "close") 처럼 지정
    * 스프링에 의존하지 않으며, 메서드 이름을 자유롭게 지정 가능
    * destroyMethod의 기본값이 추론으로 등록되어 close , shutdown 라는 이름의 메서드를 자동으로 호출한다.
3. @PostConstruct, @PreDestroy 애노테이션 지원 (**권장!**)
    * 콜백에 애노테이션 붙여줌
    * 자바에서 지원하는 javax 어노테이션이라 스프링에 의존하지 않으며, 가장 편리하고, 컴포넌트 스캔과 잘 어울림
    * 외부 라이브러리에는 적용이 어려우므로, 그럴 경우 2번을 사용