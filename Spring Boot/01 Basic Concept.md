# 기본 핵심 원리

1. [객체 지향 프로그래밍](#객체-지향-프로그래밍)
2. [객체 지향 원리 적용](#객체-지향-원리-적용)
3. [스프링 컨테이너와 스프링 빈](#스프링-컨테이너와-스프링-빈)
4. [싱글톤 컨테이너](#싱글톤-컨테이너)


## 객체 지향 프로그래밍
> 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
- 스프링 = SOLID, 다형성 극대화, 단점 보완 by IoC, DI
- 좋은? `추상화`, `캡슐화`, `상속`, `다형성`이라는 특징을 잘 살림
    * 최중요 개념 **다형성** / 객체의 관계 = **협력**
    * `역할`과 `구현` 분리: 인터페이스와 구현 객체, 설계시 역할 먼저 부여
- 프로그램을 유연하고 변경이 용이하게 만든다 (실행 시점에 구현 변경 가능)

### SOLID
- 단일 책임 원칙: 하나의 책임만 갖게 할 것. (변경의 파급이 적음)
- 개방 폐쇄 원칙: 확장에 열려 있고 변경에 닫혀 있음.
    * 하지만 다형성을 사용해도 이를 지키기 어려움. 
    * 해결: [객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자를 도입](#ocp-dip-위반-사례를-개선하기)
- 리스코프 치환 원칙: 하위 타입 인스턴스로 교체 가능함을 기능적으로 보장 (의미에 맞게, 규약 준수)
- 인터페이스 분리 원칙: 범용 인터페이스 하나보다 특정 클라이언트를 위한 구체적 인터페이스 여러개
    * 이상적으로는 모든 설계에 인터페이스를 부여하는 게 좋음
    * 그러나 인터페이스는 추상화 비용이 있음 (성능 X, 개발 과정에서의 비용)
    * 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법
- 의존 관계 역전 원칙: 구현 클래스에 의존하지 말고, 인터페이스(역할)에 의존
    * 다형성을 사용해도 인터페이스에 의존하면서 구현 클래스에도 의존하는 등 DIP를 지키기 어려움


## 객체 지향 원리 적용
### DI 컨테이너
- 스프링은 DI 컨테이너로 다형성 + OCP, DIP 가능하게 지원
- 순수 자바 코드로 OCP, DIP를 준수하려니 할 게 많아서 아예 프레임워크화한 것

### OCP, DIP 위반 사례를 개선하기
```java
// new로 구현체를 의존하던 부분을 인터페이스에만 의존하도록 설계를 변경
private MemberRepository memberRepository;

// 별다른 설정이 없으면 NPE 발생 -> 어디선가 구현체를 생성&주입해주어야 함
// AppConfig.java
public MemberService memberService() {
  return new MemberServiceImpl(memoryMemberRepository());
}

public MemoryMemberRepository memoryMemberRepository() {
  return new MemoryMemberRepository()
}

// MemberServiceImpl.java
private final MemberRepository memberRepository;

public MemberServiceImpl(MemberRepository memberRepository) {
  this.memberRepository = memberRepository;
  // 여기에 MemoryMemberRepository의 인스턴스가 들어옴
  // 생성자로 주입되고 있으므로, <생성자 주입>이라고 부른다
}
```

### 관심사 분리
- 구현 객체를 생성하고 연결하는 책임을 다른 곳에서 하게 하자
- `사용 영역`과 `구성 영역`으로 분리되었다.
    + 사용 영역: 앱의 실제 동작에 필요한 구현 객체를 생성 & 생성한 객체 인스턴스의 참조값(레퍼런스)을 생성자로 주입 (ex. `AppConfig`)
    + 구성 영역: 로직 실행 (ex. `MemberServiceImpl`)
- 이제 구현체는 자기가 사용하는 구현체를 모른다. 구체적인 프로그램 실행 방법을 모른다. 흐름 제어는 모두 AppConfig의 역할이다.

### 의존 관계의 종류
1. 정적인 클래스 의존관계
    - import 문에 의한 의존 관계
    - 애플리케이션 실행 없이 분석 가능
2. 동적인 객체 인스턴스 의존 관계
    - 애플리케이션 실행 시점(런타임)에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계
- 의존관계 주입을 사용하면...
    * 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
    * 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.

### IoC 컨테이너 또는 DI 컨테이너
> AppConfig.java
- 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것
- 최근에는 보통 DI 컨테이너라 한다. (or 어셈블러 / 오브젝트 팩토리 등)
- AppConfig를 보면 애플리케이션의 전체 구성을 빠르게 파악할 수 있다.
- 구현체가 변경되면 AppConfig만 변경하면 된다. (중복 코드 적음, 변경 간편)

### 스프링으로 바꾸기
- AppConfig에 `@Configuration`을 붙이고, 그 안의 메소드들에 `@Bean` 붙이기
    * 스프링 컨테이너는 @Configuration 이 붙은 AppConfig 를 설정(구성) 정보로 사용
    * 여기서 @Bean이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록
    * @Bean이 붙은 메서드의 이름을 스프링 빈의 이름으로 사용
- 그러면 **스프링 컨테이너**에 빈이 등록된다.
    * = 애플리케이션 콘텍스트
    * 이 친구가 모든 빈을 관리한다.
- 스프링을 사용하지 않을 경우...
    * 직접 객체 생성 및 등록
    * 직접 필요한 객체 조회
    * 모든 과정을 자바 코드로 조작
- 스프링을 사용할 경우...
    * 스프링 컨테이너를 통해 객체 생성, 등록, 조회
    * 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경


## 스프링 컨테이너와 스프링 빈
- ApplicationContext는 인터페이스로, 다형성으로 구현체로 생성
- 스프링 컨테이너는 엄밀하게는 BeanFactory, ApplicationContext으로 구분되나 전자를 직접 사용하는 경우가 드물어 후자를 보통 스프링 컨테이너라고 부른다.
    ```
    BeanFactory(인터페이스) <- ApplicationContext(인터페이스) <- 구현체 (ex. AnnotationConfigApplicationContext)
    ```
    * BeanFactory는 스프링 빈을 관리하고 조회하는 역할을 갖는다.
    * ApplicationContext는 `B.F`. + `애플리케이션을 위한 각종 부가기능`(국제화, 환경변수, 이벤트, 리소스 조회 등)
    * 구현체는 설정 형식에 따라 다르다. 자바 코드면 AnnotationConfigApplicationContext, xml이면 GenericXmlApplicationContext, ... 이런 식. (최근에는 거의 자바 코드 기반)
- 다양한 설정 형식(어노테이션/xml 등)을 지원할 수 있는 이유는 BeanDefinition 이라는 추상화가 있기 때문이다.
    * (무슨 형식이든 간에) 설정을 읽어서 **BeanDefinition을 만드는 것**이 스프링 컨테이너가 할 일!
        + ex. AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader를 사용해서 AppConfig.class를 읽고 BeanDefinition을 생성한다.
        + 직접 생성하는 것도 가능은 하지만, 실무에서 그럴 일은 거의 없다.
    * BeanDefinition
        + 빈 하나마다 하나씩 생성됨
        + 이 친구도 인터페이스라서 스프링 컨테이너는 추상에만 의존하게 됨
        + 빈 설정 메타정보 : 팩토리 빈 이름, 빈을 생성할 팩토리 메서드 등등

### 스프링 컨테이너 생성 과정
1. 스프링 컨테이너 생성
    ```java
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class)
    ``` 
    * 스프링 컨테이너에 정보 제공
    * 스프링 컨테이너 안에는 스프링 빈 저장소가 있음
2. 스프링 빈 등록
    * @Bean 붙은 거 죄다 호출해서, 스프링 빈 저장소에 메소드 이름을 key로, value를 빈 객체로 등록
    * (참고로 스프링 내부 실행을 위한 빈도 등록됨)
    * 설정에 따라 다르지만 빈 이름을 항상 유니크하게 만들 것
3. 스프링 빈 의존관계 설정
    * 설정 정보를 참고해서 의존관계를 주입함
    * 단순히 코드 호출이 되는 정도가 아니라, [싱글톤](#싱글톤-컨테이너)을 보장한다.
    * 어노테이션(자바 코드)으로 빈을 등록하면 2와 3이 한번에 실행된다.


## 싱글톤 컨테이너
- 스프링은 기본적으로 웹앱을 위한 기술이다.
- 웹앱에서는 보통 여러 사용자가 동시에 요청한다. 그때마다 객체 생성을 한다면 비효율적이다.

### 싱글톤 패턴
> 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 방법?
    * static 영역에 객체 instance를 미리 하나 생성해서 올리고
    * 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회하며
    * 새로운 인스턴스가 만들어지지 않도록 생성자를 private으로 지정
- 장점: 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다
- 단점: 코드량이 많고, 구현체에 의존하여 DIP를 위반하고, OCP를 위반할 가능성이 높음. 테스트도 어렵고 유연성이 떨어짐.

### 싱글톤 컨테이너
> = 스프링 컨테이너 <br/>
> 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 함 & **싱글톤 레지스트리로써 빈이 1개만 생성되게 강제**함
- 지저분한 코드와 getInstance() 등을 모두 스프링이 알아서 해줘서 싱글톤 패턴 없이 싱글톤으로 관리 가능
- 기본 빈 등록 방식이 싱글톤이긴 하지만, 요청할 때 마다 새로운 객체를 생성해서 반환하는 [기능]()도 제공한다
- `@Configuration`
    * 빈을 만드는 코드에서 인스턴스 생성하는 게 겹치는 것 같이 보일 수 있다.
    * 그러나 확인해보면 모두 같은 인스턴스를 공유하고 있다. (생성 코드 호출 자체가 1회만 일어남)
    * 스프링이 **클래스 바이트코드를 조작**하는 라이브러리 CGLIB를 사용하기 때문에 이와 같은 현상이 가능하다.
    * 즉, AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, **그 다른 클래스를 스프링 빈으로 등록**한 것!
    * 임의의 다른 클래스 안에는 생성 코드가 호출될 때마다 **스프링 컨테이너에서 우선 찾아보는** 과정을 거치는 로직이 포함
    * @Configuration 을 적용하지 않고, @Bean 만 적용하면 CGLIB의 적용 대상이 아니라 매번 새 인스턴스가 생성된다! 즉, 스프링 빈으로 등록은 되지만, 싱글톤을 보장하지 않는다. 설정 정보를 빈으로 등록할 땐 꼭 붙이자.

### 주의!!
- 무상태로 설계해야 한다
- 특정 클라이언트에 의존적이거나, 값을 변경할 수 있는 필드가 있으면 안 된다.
- 가급적 읽기 전용이어야 하며, 필드 대신 자바에서 공유되지 않는 지역변수/파라미터/ThreadLocal을 사용해야 한다.
- 상태를 갖게 설계할 경우 벌어질 수 있는 일 (ex. 로그인했는데 다른 사람 정보가 뜬다)


