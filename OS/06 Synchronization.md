# 프로세스 동기화
- 프로세스의 구분
    1. 독립 프로세스
    2. 협력 프로세스 (다른 프로세스 간 영향 미침)
- 협력 프로세스 간에 데이터/흐름에 대한 동기화 중요
    * 언제 인터럽트로 인한 컨택스트 스위칭이 일어날지 모름
    * instruction의 실행이 언제 끊길지 모름
    * cf. 자바의 경우에는 객체 생성을 해주기 때문에 명시적으로 join을 해줘야 데이터를 공유하게 됨
- ex. `생산자-소비자 문제`
    * 두 프로세스가 공유 변수 i에 1씩 만 번을 더하는 작업을 동시에 한다고 하면, 예상처럼 2만이 찍히지 않는다.
    * 덧셈 연산은 한 줄로 표현되지만 사실 "기존의 값을 옮겨두고", "연산하고", "변경된 값을 할당하는" 과정이 함축되어 있다. 이 각 과정마다 컨택스트 스위칭이 발생할 수 있기 때문이다.


## Race Condition (경쟁 상태)
- 경쟁 상태란? 둘 이상의 프로세스가 공유 자원에 접근할 때, 접근 순서에 따라 실행 결과가 달라질 수 있는 상태
- 왜? 공유 자원을 동시에 변경하려고 하기 때문에


## Critical Section (임계 영역)
- 임계 영역이란? 코드에서 race condition이 발생할 수 있는 부분. 즉, 각 스레드가 공유하는 데이터(변수/테이블/파일 등)를 변경하는 *코드 영역*.
- 코드 영역 구성?
    * `엔트리 섹션`: 크리티컬 섹션에 진입하는 코드 영역. 여기에서 진입 허가를 얻음.
    * `크리티컬 섹션`: 한번에 실행해야 하는 섹션은 여기에 몰아둔다.
    * `엑시트 섹션`: 진입 허가를 반납함.
    * `리메인더 섹션`: 크리티컬 섹션이 아닌 영역
- 임계 영역 문제를 해결하기 위한 3조건
    1. 상호 배제 (Mutual Exclusion)
        * 프로세스가 임계 영역에서 실행 중이라면 다른 프로세스는 접근할 수 없다.
        * 이 조건은 꼭 만족해야 한다. 
    2. 진행 (Progress)
        * deadlock 발생 방지 (아무도 진입하지 못하면 안 된다)
        * 임계 영역에 접근하는 쓰레드를 결정하는 것은 유한 시간 내에 이루어져야 한다.
        * 임계 영역에서 실행 중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 임계 영역 진입 후보가 될 수 있다.
    3. 유한 대기 (Bounded Waiting)
        * starvation 발생 방지 (무한 대기하면 안 된다)
        * 임계 영역에 진입하기 위해 대기하는 모든 쓰레드는 유한 시간 내에 임계 영역에 진입할 수 있어야 한다.
        * 프로세스가 임계 영역에 진입을 신청한 뒤부터 받아들여질 때까지, 다른 프로세스들이 임계 영역에 진입하는 횟수에 제한이 있다.


### OS에서 임계 영역 다루기
> 운영체제를 구현하는 커널 코드에는 경쟁 상태가 발생하기 쉽다. 이를 다루기 위한 방법으로는 크게 선점형 커널, 비선점형 커널이 있다.
1. 선점형
    * 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다.
2. 비선점형
    * 간단하게 동기화하는 방법이다. 인터럽트를 발생시키지 않아서, 현재 시퀀스를 반드시 보장할 수 있다.
    * 어떤 커널 모드가 한번 진입하고 나면 자발적으로 놓기 전까지는 경쟁 상태가 발생할 일이 없다.
    * 싱글 코어라면 가능할 수 있으나, 멀티 코어의 경우에는 아주 성능이 떨어지게 된다.
    * 즉, 멀티 코어가 일반적인 현대에는 사용하지 않는 방법이다.


## 임계 영역의 소프트웨어 솔루션
1. 데커의 알고리즘
    ```
    //A 프로세스의 구조
    while(1){
        flag[A] = true;
        while(flag[B]){
          if(turn == B){
                flag[A] = false;
                while(turn == B);
                flag[A] = true;
            }
        }
        V++; //critical section
        flag[A] = false;
        turn = B;
    }
    ``` 
    * 두 프로세스를 위한 정확한 상호 배제 솔루션
    * 임계 영역에 진입하겠다는 표시를 위한 flag[]
    * 임계 영역의 진입 순서를 나타내는 turn
    * flag를 변경시키고 상대방 flag를 검사한 뒤, turn 값에 따라 임계 영역에 진입함 
2. 피터슨 알고리즘
    ```
    //A 프로세스의 구조
    while(1){
        flag[A] = true;
        turn = B;
        while(flag[B] && turn == B);
        V++; //critical section
        flag[i] = false;
    }
    ```
    * 데커의 알고리즘과 구성 요소는 같음
    * 차이점? 상대(B)에게 진입 기회를 양보한다는 점 (B에게 turn을 넘기고, B가 진입 의사 표시를 하지 않았다면 while에 걸리는 거 없이 바로 임계 영역 진입 가능)
    * A 프로세스를 동작시키고 싶다면 임계 영역에 들어가고 싶다는 표시로 flag [A]를 true로 만든다.
3. 아이젠버거와 맥과이어의 알고리즘
4. 베이커리 알고리즘


## 임계 영역의 하드웨어 솔루션
- 피터슨 알고리즘은 최신 컴퓨터 아키텍처에서 작동하는 것이 보장되지 않는다. 시스템 성능을 향상하기 위해 프로세서 및 컴파일러가 종속성 없는 읽기/쓰기 작업을 재정렬할 수 있다. 즉, 논리적으로 상호 배제를 의도하고 작성한 코드라도 로우 레벨에서 기계어로 바뀔 때 실행되는 라인이 뒤집힐 수 있기 때문이다.
- 메모리 장벽은 DB 락과 유사하게, 메모리의 변경 사항이 있을 때 다른 프로세서로 전파할 수 있게 메모리 사용 순서를 제한하는 것이다. 이는 쓰레드 이점을 볼 수 없고, 매우 낮은 수준의 연산이라 특수한 코드를 작성하는 커널 개발자만 사용한다.
### 메모리 장벽
- 컴퓨터 아키텍처는 메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어(=메모리 장벽/메모리 펜스)를 제공함
- 그래서 다른 프로세서에서 실행 중인 쓰레드에 메모리 변경 사항이 보이는 것이 보장됨
- 매우 낮은 수준의 연산으로, 상호 배제를 보장하는 특수 코드를 작성할 때 커널 개발자만 사용함

### 하드웨어 명령어
- 원자적인 하드웨어 명령어
    * 더 이상 쪼갤 수 없는
    * 인터럽트 되지 않는
    * 하나의 단위로서의
1. test_and_set
    * 어떤 word의 내용을 검사하고 변경함
    * 예시
        ```
        boolean TestAndSet(boolean &target)
        {
            boolean rv = traget;
            traget = true;
            return rv;
        }

        do{
            while(TestAndSet(lock));  <--- 여기
              //critical section
            lock = false;
              //remainder section
        }
        ``` 
        1. 동시에 공유 자원에 접근하는 것을 막기 위해 임계 영역에 진입하는 프로세스가 lock을 획득해야 하고, 빠져나오면 lock을 방출해야 함으로써 **상호 배제**를 만족 (처음 접근한 프로세스가 통과한 이후, `여기`에서 lock이 true가 되어 다른 프로세스의 임계 영역 접근을 막음)
        2. 임계 영역을 끝낸 프로세스는 lock을 false로 설정하여 다른 프로세스가 임계 영역에 접근할 수 있게 함으로써 **진행** 조건 만족
        3. 하지만, **유한 대기** 조건은 만족할 수 없다
2. compare_and_swap
    * 두 word의 내용을 원자적으로 교환함
    * 예시
        ```
        void Swap(boolean &a, boolean &b)
        {
            boolean temp = a;
            a = b;
            b = temp;
        }

        do{
            key = true;
            while(key == true) Swap(lock, key);  <--- 여기
              //critical section
            lock = false;
              //remainder section
        }
        ```
        1. 임계 영역이 사용 중인지를 표시하는 lock은 false, 임계 영역에 들어갈 수 있는가를 표시하는 key는 true로 초기화하고, 둘을 swap 하면서 임계 영역에 하나의 프로세스만 진입할 수 있게 되어 **상호 배제** 조건 만족 (처음 접근한 프로세스가 통과한 이후, `여기`에서 lock이 true가 되어 다른 프로세스의 임계 영역 접근을 막음)
        2. 임계 영역 실행이 끝난 프로세스는 lock을 false로 바꾸어 다른 프로세스가 임계 영역에 접근할 수 있게 함으로써 **진행** 조건 만족
        3. 하지만, **유한 대기** 조건은 만족할 수 없다
- 원자적 변수
    * 정수/부울 등 primitive type에 대한 원자적 연산 제공
    * 원자적 변수는 데이터에 경쟁 상태가 있을 수 있는 상황에서 상호 배제를 보장하는 데 사용함
    * cf. 자바에서 long, double을 제외한 변수를 읽고 쓰는 동작은 원자적이다. (메모리 비트 크기 차이 때문에) / 공유 변수를 읽어올 때 volatile 키워드를 쓰면 캐시 영역이 아니라 메모리에서 직접 읽어서 안정을 보장할 수 있다.