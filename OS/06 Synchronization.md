# 프로세스 동기화
- 프로세스의 구분
    1. 독립 프로세스
    2. 협력 프로세스 (다른 프로세스 간 영향 미침)
- 협력 프로세스 간에 데이터/흐름에 대한 동기화 중요
    * 언제 인터럽트로 인한 컨택스트 스위칭이 일어날지 모름
    * instruction의 실행이 언제 끊길지 모름
- 인터럽트를 발생시키지 않을 수는 없다
    * 싱글 코어: 간단하게 동기화하는 방법은 인터럽트를 발생하지 않도록 하는 것. 현재 시퀀스를 반드시 보장.
    * 멀티 코어: 비선점형으로 실행한다면 성능이 아주 떨어지기 때문에 인터럽트를 아예 발생시키지 않게 하기는 어려움.
- ex. `생산자-소비자 문제`
    * 두 프로세스가 공유 변수 i에 1씩 만 번을 더하는 작업을 동시에 한다고 하면, 예상처럼 2만이 찍히지 않는다.
    * 덧셈 연산은 한 줄로 표현되지만 사실 "기존의 값을 옮겨두고", "연산하고", "변경된 값을 할당하는" 과정이 함축되어 있다. 이 각 과정마다 컨택스트 스위칭이 발생할 수 있기 때문이다.


## Race Condition (경쟁 상태)
- 경쟁 상태란? 둘 이상의 프로세스가 공유 자원에 접근할 때, 접근 순서에 따라 실행 결과가 달라질 수 있는 상태
- 왜? 공유 자원을 동시에 변경하려고 하기 때문에


## Critical Section (임계 구역)
- 임계 구역이란? 코드에서 race condition이 발생할 수 있는 부분. 즉, 각 스레드가 공유하는 데이터(변수/테이블/파일 등)를 변경하는 *코드 영역*.
- 코드 영역 구성?
    * `엔트리 섹션`: 크리티컬 섹션에 진입하는 코드 영역. 여기에서 진입 허가를 얻음.
    * `크리티컬 섹션`: 한번에 실행해야 하는 섹션은 여기에 몰아둔다.
    * `엑시트 섹션`: 진입 허가를 반납함.
    * `리메인더 섹션`: 크리티컬 섹션이 아닌 영역
- 임계 구역 문제를 해결하기 위한 3조건
    1. 상호 배제 (Mutual Exclusion)
        * 프로세스가 임계 구역에서 실행 중이라면 다른 프로세스는 접근할 수 없다.
        * 이 조건은 꼭 만족해야 한다. 
    2. 진행 (Progress)
        * deadlock 발생 방지 (아무도 진입하지 못하면 안 된다)
        * 임계 구역에 접근하는 쓰레드를 결정하는 것은 유한 시간 내에 이루어져야 한다.
        * 임계 구역에서 실행 중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 임계 구역 진입 후보가 될 수 있다.
    3. 유한 대기 (Bounded Waiting)
        * starvation 발생 방지 (무한 대기하면 안 된다)
        * 임계 구역에 진입하기 위해 대기하는 모든 쓰레드는 유한 시간 내에 임계 구역에 진입할 수 있어야 한다.
        * 프로세스가 임계 구역에 진입을 신청한 뒤부터 받아들여질 때까지, 다른 프로세스들이 임계 구역에 진입하는 횟수에 제한이 있다.
