# Thread & Concurrency
> 쓰레드는 lwp, 경량 프로세스다.


## concept
- 멀티 프로세스가 가능한 이유는 CPU의 프로그램 카운터 정보를 바꾸기 때문
- 프로그램 카운터와 레지스터 셋 정보만 별도로 유지하면, 
  같은 프로그램 안에서 굳이 fork 해서 새 프로세스를 생성하지 않아도, 
  실행 쓰레드를 달리할 수 있다.
- 즉, 프로그램 카운터와 레지스터 셋 정보는 쓰레드별로 다르게 가져가고,
  코드/데이터/파일 영역은 쓰레드끼리 공유하는 것
- cpu 입장에서 가장 기본적인 점유 단위가 됨 (pid가 아니라 그 안의 tid)


## 멀티쓰레딩의 장점
1. 높은 응답성
    * 요청을 처리할 때 blocking할 필요 없이, non-blocking으로 실행을 지속하면 됨
2. 리소스 공유에 제약이 적음
    * 프로세스 간 IPC의 경우, 중간에 쉐어드 메모리/메시지 큐 등을 써야 함
    * 쓰레드 간에는 데이터 영역이 공유되므로 IPC 구현의 복잡함을 신경쓰지 않아도 됨 
3. 경제성
    * 프로세스 하나를 생성(fork)하는 것보다 쓰레드를 만드는 것이 더 빠름
    * 컨텍스트 스위칭보다 쓰레드 스위칭이 더 빠름
4. 확장성
    * 멀티프로세서 아키텍처에서 코어가 여럿일 때 각각의 쓰레드를 붙여서 병렬 처리 가능 (?)


## 멀티코어
1. 싱글코어: 시간에 따라 interleaving (사이사이에 끼워넣기)
    * 여러 프로세스들이 번갈아가며 수행되어 마치 동시에 수행되는 것처럼 느껴지게 함
    * concurrency는 전역 자원의 공유가 어렵고, OS가 자원을 최적으로 할당하기 어렵다.
2. 멀티코어: 어떤 쓰레드는 parallel하게 돌 수 있음
    * 고려해야 할 것들
        - 태스크를 정의하기 (프로그램을 분석하여 독립된 태스크로 나눌 수 있는 영역 찾기)
        - 태스크가 적당한 밸런스의 일을 할 수 있게 하기 (태스크를 균등하게 분배)
        - 데이터를 적절하게 분리하기 (개별 프로세서에서 사용할 수 있도록)
        - 데이터간 디펜던시 고려하기 (병렬 실행 태스크가 같은 데이터에 접근하지 않게)
        - 테스트하고 디버깅하기 
- cf. 암달의 법칙: 아무리 컴퓨터(코어)의 개수가 늘어나도 속도의 개선에는 한계가 있다


## 병렬 처리
1. 데이터 병렬: 데이터를 부분화 하여 동일한 연산을 수행하는 스레드나 프로세스를 병렬적으로 실행
2. 태스크 병렬: 각 쓰레드나 프로세스가 서로 다른 연산을 수행하고 병렬적으로 실행
3. 가장 강력한 분산 처리: 네트워크에 분산된 컴퓨팅 자원을 여러 다른 컴퓨터들에서 사용할 수 있게 함. 분산 프로세스를 논리적으로 하나의 프로세스인 것처럼 실행


## 자바에서의 쓰레드
- 자바의 경우, 언어가 디자인될 때 쓰레드 기반으로 개발했기 때문에 관련 API가 많다
    1. Thread 클래스를 상속
    2. Runnable 인터페이스 (다중상속이 안 되므로 인터페이스 사용)
    3. 쓰레드 코드는 간단한데 굳이 구현을..? -> lambda expression. 새 클래스 선언 없이 사용 가능 
- 사용자 수준의 쓰레드 라이브러리가 관리하는 쓰레드는 `유저 쓰레드`라고 한다 (ex. `POSIX Pthreads`, `Win32 threads`, `Java threads`)
- `커널 쓰레드`는 안정적이지만, 유저 모드와 커널 모드 간 컨텍스트 스위칭이 자주 일어나 성능 저하
