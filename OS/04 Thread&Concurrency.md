# Thread & Concurrency
> 쓰레드는 lwp, 경량 프로세스다.


## concept
- 멀티 프로세스가 가능한 이유는 CPU의 프로그램 카운터 정보를 바꾸기 때문
- 프로그램 카운터와 레지스터 셋, 스택만 별도로 유지하면, 
  같은 프로그램 안에서 굳이 fork 해서 새 프로세스를 생성하지 않아도, 
  실행 쓰레드를 달리할 수 있다.
- 즉, 프로그램 카운터와 레지스터 셋, 스택은 쓰레드별로 다르게 가져가고,
  코드/데이터/파일 영역은 쓰레드끼리 공유하는 것
- cpu 입장에서 가장 기본적인 점유 단위가 됨 (pid가 아니라 그 안의 tid)


## 멀티쓰레딩의 장점
1. 높은 응답성
    * 요청을 처리할 때 blocking할 필요 없이, non-blocking으로 실행을 지속하면 됨
2. 리소스 공유에 제약이 적음
    * 프로세스 간 IPC의 경우, 중간에 쉐어드 메모리/메시지 큐 등을 써야 함
    * 쓰레드 간에는 데이터 영역이 공유되므로 IPC 구현의 복잡함을 신경쓰지 않아도 됨 
3. 경제성
    * 프로세스 하나를 생성(fork)하는 것보다 쓰레드를 만드는 것이 더 빠름
    * 컨텍스트 스위칭보다 쓰레드 스위칭이 더 빠름
4. 확장성
    * 멀티프로세서 아키텍처에서 코어가 여럿일 때 각각에서 쓰레드를 붙여서 병렬 처리 가능


## 멀티코어
1. 싱글코어: 시간에 따라 interleaving (사이사이에 끼워넣기)
    * 여러 프로세스들이 번갈아가며 수행되어 마치 동시에 수행되는 것처럼 느껴지게 함
    * concurrency는 전역 자원의 공유가 어렵고, OS가 자원을 최적으로 할당하기 어렵다.
2. 멀티코어: 어떤 쓰레드는 parallel하게 돌 수 있음
    * 고려해야 할 것들
        - 태스크를 정의하기 (프로그램을 분석하여 독립된 태스크로 나눌 수 있는 영역 찾기)
        - 태스크가 적당한 밸런스의 일을 할 수 있게 하기 (태스크를 균등하게 분배)
        - 데이터를 적절하게 분리하기 (개별 프로세서에서 사용할 수 있도록)
        - 데이터간 디펜던시 고려하기 (병렬 실행 태스크가 같은 데이터에 접근하지 않게)
        - 테스트하고 디버깅하기 
- cf. 암달의 법칙: 아무리 컴퓨터(코어)의 개수가 늘어나도 속도의 개선에는 한계가 있다


## 병렬 처리
1. 데이터 병렬: 데이터를 부분화 하여 동일한 연산을 수행하는 쓰레드나 프로세스를 병렬적으로 실행
2. 태스크 병렬: 각 쓰레드나 프로세스가 서로 다른 연산을 수행하고 병렬적으로 실행
3. 가장 강력한 분산 처리: 네트워크에 분산된 컴퓨팅 자원을 여러 다른 컴퓨터들에서 사용할 수 있게 함. 분산 프로세스를 논리적으로 하나의 프로세스인 것처럼 실행


## User Threads와 Kernel Threads
- `유저 쓰레드`: 사용자 수준의 쓰레드 라이브러리가 관리하는 쓰레드 (ex. `POSIX Pthreads`, `Win32 threads`, `Java threads`) 
- `커널 쓰레드`: 커널이 지원하는 쓰레드. 안정적이지만, 유저 모드와 커널 모드 간 컨텍스트 스위칭이 자주 일어나 성능 저하
- 유저 쓰레드와 커널 쓰레드 간 관계 모델
    1. Many-to-One Model
        * 하나의 커널 쓰레드에 여러 개의 유저 쓰레드를 연결
        * 한 번에 하나의 유저 쓰레드만 커널에 접근할 수 있기 때문에 멀티코어 시스템에서 병렬적인 수행을 할 수가 없음
    2. One-to-One Model
        * 하나의 유저 쓰레드에 하나의 커널 쓰레드가 대응
        * 동시성을 높여주고, 멀티프로세서 시스템에서는 동시에 여러 쓰레드를 수행할 수 있도록 함.
        * 유저 쓰레드를 늘리면 커널 쓰레드도 똑같이 늘어나는데, 커널 쓰레드를 생성하는 것은 오버헤드가 큰 작업이기 때문에 성능 저하가 발생할 수 있음.
    3. Many-to-Many Model
        * 여러 유저 쓰레드에 더 적거나 같은 수의 커널 쓰레드가 대응
        * OS가 충분한 수(구체적인 것은 환경에 따라 상이)의 커널 쓰레드를 만들 수 있음


## 쓰레드 라이브러리
> 쓰레드 라이브러리는 쓰레드를 생성 및 관리하는 API를 제공한다.
- 주요 쓰레드 라이브러리
    * POSIX PThreads
    * Windows thread
    * Java Threads (JVM-OS)
- 자바에서의 쓰레드
    * 자바의 경우, 언어가 디자인될 때 쓰레드 기반으로 개발했기 때문에 관련 API가 많다
        1. Thread 클래스를 상속
        2. Runnable 인터페이스 (다중상속이 안 되므로 인터페이스 사용)
        3. 쓰레드 코드는 간단한데 굳이 구현을..? -> lambda expression. 새 클래스 선언 없이 사용 가능 
    * cf. `start`는 쓰레드 정보를 세팅하고, `run`을 호출한다.


## Implicit Threading
> 프로그래머가 직접 쓰레드를 관리하는 것은 복잡하고 번거롭기 때문에, 쓰레드의 생성과 관리를 컴파일러/런타임 라이브러리에 위임하는 방식
1. Thread Pools
    * 쓰레드가 필요하면 미리 만들어둔 풀에서 갖다 쓰는 것
    * 한정된 자원을 무리하게 사용하지 않게 미리 배정해둠 
2. Fork & Join
    * 명시적 쓰레딩뿐 아니라, 암시적 쓰레딩을 할 수 있는 방법도 있음
    * 메인 부모 스레드가 하나 이상의 자식 스레드를 fork한 다음 자식의 종료를 기다린 후 join하고 그 시점 부터 자식의 결과를 확인하고 결합하는 방법
3. OpenMP
    * 컴파일러에 지시어로 C, C++에서 병렬처리를 지원하는 것
    * 쉐어드 메모리 환경에서 병렬 실행을 가능하게 함
    * 병렬 처리할 영역을 정의해두면, 컴파일러가 해당 코드 블록을 알아서 병렬로 실행해줌 (코어 수만큼 쓰레드 생성)
4. GCD: 애플의 운영체제에서 사용
