# 주메모리의 관리

프로세스란 실행 중인 프로그램
실행 중이라는 것은 메모리에 로드되어 있다는 것
메모리는 바이트 단위로 구성된 정보를 저장하는, 비트를 8개로 묶어서, 하나의 바이트로 배열을 쭉 저장해둔 걸 메모리.
메모리에는 주소가 있다.
CPU는 메모리에서 인스트럭션을 패치해와서 그걸 실행하는데, 그 명령어도 로드가 있고 스토어가 있어서 그거는 메모리에 접근함

메모리에 프로세스를 어떻게 나눠 관리하느냐? <-주요 토픽
각 프로세스가 따로따로 관리를 할 수 있는 게 멀티프로세싱의 기본
두 개의 베이스 레지스터, 리미트 레지스터라는 걸 갖고 합법적인 주소의 액세스를 제어해줄 필요가 있다.
베이스보다 작거나 베이스+리밋보다 크면 공간을 넘어선다고 판단하는 식

주소를 다루는 방식은 단계별로 다 다르다
일반적으로 변수의 메모리 공간 지정은 컴파일러가 하는데,
a 라는 변수의 지정은 심볼릭하고,
a 라는 메모리 주소 공간에 값을 써줘라고 요청하는 것.
그 a 자체의 위치를 컴파일러가 지정한다는 것.
컴파일러의 프로그램 역시 바이너리 실행 파일로 저장되어 있는 것. (-> 디스크에 저장)

이걸 실행시키기 위해 프로그램을 메모리에 갖고 오면,
그제야 비로소 프로세스가 된다.

주소의 바인딩
로지컬 주소 -> 피지컬 주소
ㄴ 둘은 직접 연관 없어야
매핑해주는 방법: 논리주소공간, 물리주소공간의 분리
cpu - mmu -> p.m.
mmu의 역할: 논리주소가 물리주소로 변형
리로케이션 레지스터가 베이스 레지스터 역할을 함

다이나믹 로딩
모든 프로그램 데이터가 메모리에 올라올 필요는 없다
메모리 주소 공간을 효율적으로 사용하기 위해
모든 루틴을 한번에 로딩할 필요가 없기 때문
필요할 때만 호출해주자는 아이디어.
필요한 루틴을 호출할 때 주소 테이블에 반영해주면 됨

dll: 쉐어드 라이브러리.
시스템 라이브러리인데, 유저 프로그램이 실행되는 중에 링킹 되는 것.
- 정적 링킹: 다른 오브젝트 모듈처럼 로더가 바이너리 코드를 링킹함
- 동적 링킹: 다이나믹 로딩처럼 링킹을 실행시까지 연기함.

연속 메모리 할당
- hole: 링크드 리스트

단편화
external fragmentation(외부 단편화)
internal framgmentation(내부 단편화)

segmentation
프로세스를 세그먼트의 집합으로 여김
물리적인 크기의 단위가 아닌 논리적 내용의 단위(의미가 같은)로 자름
페이징 (=똑같은 크기로 쪼개기) 과 메모리 할당법은 같음