# Process
> 실행 중인 프로그램


## 프로세스란?
- 디스크에 있으면 프로그램, 메모리에 로드되면 프로세스.
- 프로그램은 하나지만, 프로세스는 여러 개일 수 있다.
- 구조
    - text (코드)
    - data (전역 변수)
    - heap (메모리 할당)
    - stack (함수 호출, 지역 변수 등)


## 프로세스 상태
- OS는 프로세스를 관리해야 한다
    * 프로세스를 관리한다 = state를 바꾼다
- 상태(state)
    * [processState](../images/os_3_1.png)
    * New: 프로세스가 처음 생성됨 (`fork()`)
    * Ready: 프로세서에 할당되기를 기다림 (in `ready queue`)
    * Running: 프로세서가 할당되어 실행됨
    * Waiting: 프로세스가 이벤트를 기다림
    * Terminated: 프로세스가 실행을 마침


## Process Control Block (PCB)
> OS가 관리하는, 각각의 프로세스가 가진 자신의 정보 묶음
- **Process state**: 프로세스의 상태.
- **Program counter**: 해당 프로세스가 이어서 실행해야 할 명령의 주소를 가리키는 카운터.
- CPU registers: 프로세스가 인터럽트 이후 올바르게 작업을 이어가기 위해 참조하는 CPU 레지스터 값.
- CPU-scheduling information: 프로세스의 중요도, 스케줄링 큐 포인터 등 스케줄링 파라미터 정보.
- Memory-management information: base, limit 레지스터 값, 페이지 테이블 등 메모리 시스템 정보.
- Accounting information: 사용된 CPU 총량, 프로세스 개수, 시간 제한 등.
- I/O status information: 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등.


## 쓰레드
> 일종의 경량 프로세스
- 프로그램이 복잡해지며 멀티 프로그래밍을 하면서도, 내부에서 멀티 프로세싱이 필요해져서 등장
    * 싱글 스레드 프로세스는 한 번에 하나의 태스크만 가능
    * 하나의 프로세스가 여러 태스크를 동시에 실행하려면 스레드가 필요 
- 멀티 xxx
    * 멀티프로그래밍
        + 목적: CPU를 최대 효율로 사용하며 자원 낭비를 막음
        + 의미: 메모리에 여러 프로그램을 동시에 올림
    * 멀티태스킹 (a.k.a. 타임쉐어링)
        + 목적: 동시에 수행하는 것처럼 보이기
        + 의미: 정해진 시간 동안 각각의 프로세스를 번갈아 수행(스위칭)하며 동시성을 구현함
    * 멀티프로세싱
        + 의미: 다수의 프로세서가 서로 협력하여 일을 처리함
    * 멀티스레딩
        + 의미: 하나의 프로세스를 여러 스레드끼리 자원을 공유하며 실행함
- 동시 vs 병렬
    * [동시,병렬](../images/os_3_2.png)
    * 동시성concurrency: 동시에 실행되는 것처럼 보이는 것
        + 싱글 코어에서 멀티 쓰레드를 동작
    * 병렬성parallelism: 실제로 동시에 여러 작업이 처리되는 것
        + 멀티 코어에서 멀티 쓰레드를 동작


## 프로세스 스케줄링
> 어떤 프로세스를 프로세서에 할당할 것인가
- 스케줄링 큐
    * job 큐: 프로세스가 시스템에 들어올 때 들어감
    * **ready 큐**: 메인 메모리에서 실행을 기다리는 ready 상태의 프로세스
    * **waiting 큐**: 특정한 이벤트마다 대기하는 프로세스를 유지시킴
    * device 큐: 입출력 장치를 기다리는 프로세스
- 스케줄러
    * job 스케줄러(a.k.a. `long-term 스케줄러`): 레디 큐에 프로세스를 옮김. CPU 밖에서 가끔 수행.
    * cpu 스케줄러(a.k.a. `short-term 스케줄러`): 프로세스를 프로세서에 할당. CPU 내부에서 자주 수행
- 프로세스의 실행
    * 부모가 fork로 새로운 자식 프로세스를 생성한다 (**New**)
    * 자식은 CPU 획득을 위해 대기하면서 **Ready** 큐에 들어간다.
    * CPU 스케줄링으로 OS가 프로세스에 자원을 할당하면 **Running** 상태가 된다.
    * 너무 오래 자원을 점유하고 있다면 인터럽트를 받을 수 있다. 그러면 다시 **Ready**상태가 된다.
    * 메모리 I/O를 하기 위한 대기는 **Waiting** 큐에서 이루어진다. 역시 끝나면 **Ready**상태가 된다.


## Context Switch
> 프로세스 실행 중 발생한 인터럽트로 OS가 개입하여 프로세서에 할당된 프로세스를 바꾸는 것
- 프로세스는 CPU들을 time sharing 해서 context switch를 하면서 concurrent하게 실행하도록 함
- 프로세서 입장에서...
    * context? 프로세스 상태 정보. PCB.
    * context switching? PCB 정보가 바뀌는 것.
- 어떻게 바꾸나? CPU 코어를 다른 프로세스에게 넘겨준다
    * current context를 프로그램 카운터에 저장함
    * 다른 새로운 프로세스의 상태를 로드함
    * 다시 이전에 작업한 프로세스를 획득하면 컨텍스트 복원
- 주의: 오버헤드가 발생 & 너무 잦으면 성능 저하


## 프로세스 작업
> OS는 프로세스 생성, 종료를 제공해야 한다
1. 생성
    - 프로세스는 트리 구조
    - 부모 --(`fork()`)--> 자식
        * 부모가 `fork()`로 자신과 같은 자식을 생성
        * 자식은 `exec()`으로 자신을 호출한 프로세스의 메모리에 데이터를 덮어 쓴다.
    - fork()
        * 부모에게는 자식의 pid를, 자식에게는 0을 리턴함.
        * 자식은 부모의 주소 공간을 복사해서 사용함.
    - 부모&자식은 동시에 작동
2. 종료
    - exit()
    - 부모X, 자식O: 자식이 orphan. 자식은 그 상위 프로세스를 부모로 바라봄
    - 부모O, 자식X, 자식 정보 회수 안함: 자식이 zombie.  (종료되었으나 메모리에 남아 있다) 부모가 wait() 호출시 제거됨.


## Interprocess Communication (IPC)
- 프로세스는 기본적으로 상호 독립이지만, 필요에 따라 서로 협력하며 동작할 수 있다.
- 협력 프로세스들 간에는 통신이 필요하다. 데이터를 주고받는 방법은 IPC 매커니즘에는 크게 두 가지가 있다.
    1. Shared Memory (게시판)
        > 데이터를 함께 사용한다. 
        * 특정 메모리 공간을 두 프로세스가 공유함
        * 장점: 속도가 빠름
        * 단점: 메모리에 동시에 접근하는 것을 막기 위한 별도의 구현 필요
        * Producer-Consumer Problem
            + 생산 속도가 소비 속도보다 빨라서 동기화 문제가 발생할 수 있기 때문에 생산된 데이터를 buffer에 담아 둔다.
            + 생산자는 buffer를 채우고, 소비자는 buffer를 비운다.
            + 크기의 한계가 있는 버퍼는 Bounded buffer, 버퍼의 시작과 끝을 이어붙여 크기가 무한한 버퍼를 Unbounded buffer라 한다.
        * ex. **POSIX**
            + memory mapped file: 쉐어드 메모리로 사용할 영역을 잡고, 파일을 생성하여 쉐어드 메모리 영역을 파일에 매핑한다.
            + 하나하나 open, write, read, close 필요
    2. Message Passing (우편)
        > 데이터를 주고받는다. 
        * `커널`을 통해 데이터를 전달
        * 장점: 커널이 기본적 기능(ex. 시스템 콜 send() 등)을 제공하여 구현이 쉬움
        * 단점: 커뮤니케이션 링크를 만들어야 하는 등의 과정으로 인해 컨텍스트 스위칭 발생 (속도 느림)
            + physical communication link: shared memory, hardware bus, network
            + logical communication link
                - direct or indirect
                    - direct: 일대일 통신. 명시적으로 특정한 수신자나 생산자를 지정하면 자동으로 링크가 생성된다.
                    - indirect: 다대다 통신. 메시지는 포트(mailbox)에서 송수신된다.
                - synchronous or asynchronous
                - automatic or explicit buffering
        * Synchronization
            + blocking (동기)
                - send: 수신될 때까지 block
                - receive: 메시지를 수신할 때까지 block
            + non-blocking (비동기)
                - send: 전송하고 멈춤 없이 계속함
                - receive: valid하거나 null한 메시지를 수신하더라도 계속 수신함
        * ex. **Pipes**
            + 하나의 프로세스가 파이프를 통해 다른 프로세스로 메시지를 직접 전달.
            + 유닉스 초창기의 간단한 IPC 매커니즘. 리눅스는 모든 것을 파일로 여기는데, 마찬가지로 파이프도 파일이다.
            + 방향
                - 기본적으로 단방향 통신만 지원 (half-duplex)
                - 양방향 통신을 원한다면, 두 개의 파이프를 사용해야 함 (full-duplex)
            + 종류
                1. Ordinary Pipe
                    - 부모-자식 프로세스 간에 일반적으로 사용함
                2. Named Pipe
                    - 연관 없는 프로세스 간에도 사용 가능 (통신을 위해 이름이 있는 파일을 매개하기 때문)
        * ex. **Socket**
            + 네트워크 상에서 이루어지는 프로세스 간 통신.
                - OSI 7 layer 구조의 Application Layer(L7)에서 Transport Port(L4)의 TCP 또는 UDP를 이용하기 위한 수단
                - 실질적으로는 로컬 컴퓨터의 프로세스와 원격지 컴퓨터의 프로세스가 IPC 통신을 하는 것
            + 장점: 대부분의 언어에서 API 형태로 제공하는 편리함
            + 단점: 일련의 통신 과정을 직접 구현하므로 통신 관련 장애를 처리하는 것은 고스란히 개발자의 몫 + 데이터 포매팅의 복잡성
            + 커뮤니케이션의 양 종단(endpoint)으로 정의됨. (IP 주소 + 포트 = 소켓)
                - IP 주소로 컴퓨터를 특정하고, port로 파이프를 특정한다.
                - IP주소와 포트 정보가 있으면 클라이언트는 네트워크를 통해 서버 프로세스에 접근할 수 있다.
                - 양방향 통신 & 서버(bind, listen, accept)-클라이언트(connect)
            + Java Interface
                - Socket (TCP)
                - DatagramSocket (UDP)
                - MulticastSocket (DatagramSocket의 하위 개념, 일종의 그룹에 추가)
        * ex. **RPC** (Remote Procedure Calls)
            + 네트워크로 연결된 서버 상의 프로시저(함수, 메서드 등)를 원격으로 호출할 수 있는 기능
            + 원격에 위치한 프로그램을 로컬의 것처럼 사용 가능
            + 장점
                - 로컬에서 제공하는 빠른 속도, 가용성 등을 분산 프로그래밍에서도 제공
                - 통신이나 call 방식에 신경쓰지 않고 원격지의 자원을 내 것처럼 사용할 수 있음
                - IDL(Interface Definition Language)를 사용해 서버의 호출 규약을 정의하여 다양한 언어를 가진 환경에서도 쉬운 확장 가능, 인터페이스 협업에 용이
            + 단점: 구현의 어려움, 지원 기능의 한계
            + 클라이언트 보조 객체 `Stub`
                - 리모트 프로그램의 대리자
                - 역할
                    1. 함수 호출에 사용된 파라미터를 변환(Marshalling. 데이터 -> 바이트; 전송 가능한 형태로 변환)
                    2. 함수 실행 후 서버에서 전달 된 결과의 변환
            + 서버 보조 객체 `Skeleton`
                - 요청 메세지를 수신해 이해하고 데이터를 서비스 측 비즈니스 객체로 전달
                - 역할
                    1. 클라이언트가 전달한 매개 변수의 역변환(Unmarshalling. 전송 받은 데이터를 원래 형태로 복원.)
                    2. 함수 실행 결과 변환
            + 왜 보조 객체가 필요한가? 서버와 클라이언트는 서로 다른 주소 공간을 사용하므로, 파라미터 변환이 없다면 포인터가 양측에서 다른 데이터를 가리키게 되기 때문
            + RPC 통신 과정
                1. IDL(Interface Definition Language)을 사용하여 호출 규약을 정의
                    * 함수명, 인자, 반환값에 대한 데이터형이 정의된 IDL 파일을 rpcgen으로 컴파일
                    * 컴파일하면 stub code가 자동으로 생성
                2. Stub Code에 명시된 함수는 원시코드의 형태로, 상세 기능은 server에서 구현됨
                    * 만들어진 stub 코드는 클라이언트/서버에 함께 빌드함
                3. client에서 stub 에 정의된 함수를 사용
                4. client stub은 RPC runtime을 통해 함수 호출
                5. server는 수신된 procedure 호출에 대한 처리 후 결과 값을 반환
                6. 최종적으로 Client는 Server의 결과 값을 반환받고, 함수를 Local에 있는 것 처럼 사용할 수 있음
            + ex. `RMI` (Remote Method Invocation, RPC의 Java 구현)
        * cf. REST (REpresentational State Transfer)
            + URI로 자원을 명시하고, HTTP method로 처리하는 구조
            + 장점: 직관적이고 쉽다
            + 단점: 파라미터/응답값이 명시적이지 않음, HTTP method에 의존하여 기능이 한정적, 직렬화가 필요한 데이터 구조 xml과 json
            + RPC와 비교해보면... (e.g.)
                1. 호출하는 url은 `자원의 위치`(REST) `동작`(RPC)
                2. 응답값은 `미리 정의된 코드`(REST) `함수의 리턴값`(RPC)
        * cf. gRPC (google Remote Procedure Call)
            + HTTP/2를 사용하여 프로토콜 버퍼로 데이터를 전송하는 RPC 프레임워크
            + 장점
                - HTTP/2의 장점? 하나의 커넥션으로 여러개 메시지 & 헤더 압축
                - 프로토콜 버퍼의 장점? 더 적은 양의 데이터로 데이터를 직렬화하는 기법 
- 이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 **세마포어**와 **뮤텍스**를 사용한다.


#### IPC별 특징 요약
|    IPC 종류    |              PIPE             |            Named PIPE             |            Message Queue            |          Shared Memory           |            Memory Map             |             Socket              |
|:--------------:|:-----------------------------:|:---------------------------------:|:----------------------------------:|:--------------------------------:|:---------------------------------:|:-------------------------------:|
|    사용 시기   |  부모 자식 간 단 방향 통신 시 | 다른 프로세스와  단 방향 통신 시  | 다른 프로세스와  단 방향 통신 시   | 다른 프로세스와 양 방향 통신 시  | 다른 프로세스와  양 방향 통신 시  |  다른 시스템간  양 방향 통신 시 |
|   공유 매개체  |             파일              |               파일                |               메모리               |              메모리              |            파일+메모리            |              소켓               |
|    통신 단위   |             Stream            |               Stream              |               구조체               |              구조체              |               페이지              |             Stream              |
|    통신 방향   |             단 방향           |              단 방향              |              단 방향               |             양 방향              |              양 방향              |             양 방향             |
| 통신 가능 범위 |           동일 시스템         |            동일 시스템            |            동일 시스템             |           동일 시스템            |            동일 시스템            |       동일 + 외부  시스템       |

- cf. 구조체: 타입이 다른 데이터를 하나로 묶는 방법