# Process
> 실행 중인 프로그램


## 프로세스란?
- 디스크에 있으면 프로그램, 메모리에 로드되면 프로세스.
- 프로그램은 하나지만, 프로세스는 여러 개일 수 있다.
- 구조
    - text (코드)
    - data (전역 변수)
    - heap (메모리 할당)
    - stack (함수 호출, 지역 변수 등)


## 프로세스 상태
- OS는 프로세스를 관리해야 한다
    * 프로세스를 관리한다 = state를 바꾼다
- 상태(state)
    * [processState](../images/os_3_1.png)
    * New: 프로세스가 처음 생성됨 (`fork()`)
    * Ready: 프로세서에 할당되기를 기다림 (in `ready queue`)
    * Running: 프로세서가 할당되어 실행됨
    * Waiting: 프로세스가 이벤트를 기다림
    * Terminated: 프로세스가 실행을 마침


## Process Control Block (PCB)
> OS가 관리하는, 각각의 프로세스가 가진 자신의 정보 묶음
- **Process state**: 프로세스의 상태.
- **Program counter**: 해당 프로세스가 이어서 실행해야 할 명령의 주소를 가리키는 카운터.
- CPU registers: 프로세스가 인터럽트 이후 올바르게 작업을 이어가기 위해 참조하는 CPU 레지스터 값.
- CPU-scheduling information: 프로세스의 중요도, 스케줄링 큐 포인터 등 스케줄링 파라미터 정보.
- Memory-management information: base, limit 레지스터 값, 페이지 테이블 등 메모리 시스템 정보.
- Accounting information: 사용된 CPU 총량, 프로세스 개수, 시간 제한 등.
- I/O status information: 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등.


## 쓰레드
> 일종의 경량 프로세스
- 프로그램이 복잡해지며 멀티 프로그래밍을 하면서도, 내부에서 멀티 프로세싱이 필요해져서 등장
    * 싱글 스레드 프로세스는 한 번에 하나의 태스크만 가능
    * 하나의 프로세스가 여러 태스크를 동시에 실행하려면 스레드가 필요 
- 멀티 xxx
    * 멀티프로그래밍
        + 목적: CPU를 최대 효율로 사용하며 자원 낭비를 막음
        + 의미: 메모리에 여러 프로그램을 동시에 올림
    * 멀티태스킹 (a.k.a. 타임쉐어링)
        + 목적: 동시에 수행하는 것처럼 보이기
        + 의미: 정해진 시간 동안 각각의 프로세스를 번갈아 수행(스위칭)하며 동시성을 구현함
    * 멀티프로세싱
        + 의미: 다수의 프로세서가 서로 협력하여 일을 처리함
    * 멀티스레딩
        + 의미: 하나의 프로세스를 여러 스레드끼리 자원을 공유하며 실행함
- 동시 vs 병렬
    * [동시,병렬](../images/os_3_2.png)
    * 동시성concurrency: 동시에 실행되는 것처럼 보이는 것
        + 싱글 코어에서 멀티 쓰레드를 동작
    * 병렬성parallelism: 실제로 동시에 여러 작업이 처리되는 것
        + 멀티 코어에서 멀티 쓰레드를 동작


## 프로세스 스케줄링
> 어떤 프로세스를 프로세서에 할당할 것인가
- 스케줄링 큐
    * job 큐: 프로세스가 시스템에 들어올 때 들어감
    * **ready 큐**: 메인 메모리에서 실행을 기다리는 ready 상태의 프로세스
    * **waiting 큐**: 특정한 이벤트마다 대기하는 프로세스를 유지시킴
    * device 큐: 입출력 장치를 기다리는 프로세스
- 스케줄러
    * job 스케줄러(a.k.a. `long-term 스케줄러`): 레디 큐에 프로세스를 옮김. CPU 밖에서 가끔 수행.
    * cpu 스케줄러(a.k.a. `short-term 스케줄러`): 프로세스를 프로세서에 할당. CPU 내부에서 자주 수행
- 프로세스의 실행
    * 부모가 fork로 새로운 자식 프로세스를 생성한다 (**New**)
    * 자식은 CPU 획득을 위해 대기하면서 **Ready** 큐에 들어간다.
    * CPU 스케줄링으로 OS가 프로세스에 자원을 할당하면 **Running** 상태가 된다.
    * 너무 오래 자원을 점유하고 있다면 인터럽트를 받을 수 있다. 그러면 다시 **Ready**상태가 된다.
    * 메모리 I/O를 하기 위한 대기는 **Waiting** 큐에서 이루어진다. 역시 끝나면 **Ready**상태가 된다.


## Context Switch
> 프로세스 실행 중 발생한 인터럽트로 OS가 개입하여 프로세서에 할당된 프로세스를 바꾸는 것
- 프로세서 입장에서...
    * context? 프로세스 상태 정보. PCB.
    * context switching? PCB 정보가 바뀌는 것.
- 어떻게 바꾸나? CPU 코어를 다른 프로세스에게 넘겨준다
    * current context를 프로그램 카운터에 저장함
    * 다른 새로운 프로세스의 상태를 로드함
    * 다시 이전에 작업한 프로세스를 획득하면 컨텍스트 복원
- 주의: 오버헤드가 발생 & 너무 잦으면 성능 저하

## 프로세스 작업
> OS는 프로세스 생성, 종료를 제공해야 한다
1. 생성
    - 프로세스는 트리 구조
    - 부모 --(`fork()`)--> 자식
        * 부모가 `fork()`로 자신과 같은 자식을 생성
        * 자식은 `exec()`으로 자신을 호출한 프로세스의 메모리에 데이터를 덮어 쓴다.
    - fork()
        * 부모에게는 자식의 pid를, 자식에게는 0을 리턴함.
        * 자식은 부모의 주소 공간을 복사해서 사용함.
    - 부모&자식은 동시에 작동
2. 종료
    - exit()
    - 부모X, 자식O: 자식이 orphan. 자식은 그 상위 프로세스를 부모로 바라봄
    - 부모O, 자식X, 자식 정보 회수 안함: 자식이 zombie.  (종료되었으나 메모리에 남아 있다) 부모가 wait() 호출시 제거됨.


## Interprocess Communication (IPC)
- 프로세스는 독립적으로 동작하거나 서로 협력하며 동작할 수 있다.
- 협력 프로세스들 간에는 통신이 필요하다. 데이터를 주고받는 방법은 IPC 매커니즘에는 크게 두 가지가 있다.
    1. Shared Memory (게시판)
        > 데이터를 함께 사용한다. 
        * 특정 메모리 공간을 두 프로세스가 공유함
        * 장점: 속도가 빠름
        * 단점: 메모리에 동시에 접근하는 것을 막기 위한 별도의 구현 필요
        * Producer-Consumer Problem
            + 생산 속도가 소비 속도보다 빨라서 동기화 문제가 발생할 수 있기 때문에 생산된 데이터를 buffer에 담아 둔다.
            + 생산자는 buffer를 채우고, 소비자는 buffer를 비운다.
            + 크기의 한계가 있는 버퍼는 Bounded buffer, 버퍼의 시작과 끝을 이어붙여 크기가 무한한 버퍼를 Unbounded buffer라 한다.
        * ex. **POSIX**
            + memory mapped file: 쉐어드 메모리로 사용할 영역을 잡고, 파일을 생성하여 쉐어드 메모리 영역을 파일에 매핑한다.
            + 하나하나 open, write, read, close 필요
    2. Message Passing (우편)
        > 데이터를 주고받는다. 
        * `커널`을 통해 데이터를 전달
        * 장점: 커널이 기본적 기능(ex. 시스템 콜 send() 등)을 제공하여 구현이 쉬움
        * 단점: 커뮤니케이션 링크를 만들어야 하는 등의 과정으로 인해 컨텍스트 스위칭 발생 (속도 느림)
            + physical communication link: shared memory, hardware bus, network
            + logical communication link
                - direct or indirect
                    - direct: 일대일 통신. 명시적으로 특정한 수신자나 생산자를 지정하면 자동으로 링크가 생성된다.
                    - indirect: 다대다 통신. 메시지는 포트(mailbox)에서 송수신된다.
                - synchronous or asynchronous
                - automatic or explicit buffering
        * Synchronization
            + blocking (동기)
                - send: 수신될 때까지 block
                - receive: 메시지를 수신할 때까지 block
            + non-blocking (비동기)
                - send: 전송하고 멈춤 없이 계속함
                - receive: valid하거나 null한 메시지를 수신하더라도 계속 수신함
        * ex. **Pipes**
            + 유닉스 초창기의 간단한 IPC 매커니즘. 리눅스는 모든 것을 파일로 여기는데, 마찬가지로 파이프도 파일이다.
            + 방향
                - 기본적으로 단방향 통신만 지원 (half-duplex)
                - 양방향 통신을 원한다면, 두 개의 파이프를 사용해야 함 (full-duplex)
            + 종류
                1. Ordinary Pipe
                    - 부모-자식 프로세스 간에 일반적으로 사용함
                2. Named Pipe
                    - 연관 없는 프로세스 간에도 사용 가능 (통신을 위해 이름이 있는 파일을 매개하기 때문)


#### IPC별 특징 요약
|    IPC 종류    |              PIPE             |            Named PIPE             |            Mesage Queue            |          Shared Memory           |            Memory Map             |             Socket              |
|:--------------:|:-----------------------------:|:---------------------------------:|:----------------------------------:|:--------------------------------:|:---------------------------------:|:-------------------------------:|
|    사용 시기   |  부모 자식 간 단 방향 통신 시 | 다른 프로세스와  단 방향 통신 시  | 다른 프로세스와  단 방향 통신 시   | 다른 프로세스와 양 방향 통신 시  | 다른 프로세스와  양 방향 통신 시  |  다른 시스템간  양 방향 통신 시 |
|   공유 매개체  |             파일              |               파일                |               메모리               |              메모리              |            파일+메모리            |              소켓               |
|    통신 단위   |             Stream            |               Stream              |               구조체               |              구조체              |               페이지              |             Stream              |
|    통신 방향   |             단 방향           |              단 방향              |              단 방향               |             양 방향              |              양 방향              |             양 방향             |
| 통신 가능 범위 |           동일 시스템         |            동일 시스템            |            동일 시스템             |           동일 시스템            |            동일 시스템            |       동일 + 외부  시스템       |