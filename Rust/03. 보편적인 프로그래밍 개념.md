# 보편적인 프로그래밍 개념

## 변수와 가변성
- 기본 변수는 불변 (for 안전성, 손쉬운 동시성)
    * `let` 키워드 사용
    * 이름에 값이 바인딩되면 변경할 수 없다.
    * 변수 값의 변화를 추적할 필요가 없다.
- 변수명의 접두어로 `mut`을 추가해서 가변 변수 선언 가능
    * `const` 키워드 사용 & 타입 선언 필요
    * 단, 상수는 가변화할 수 없다.
    * 표현식만 사용할 수 있고 런타임에 결정되는 값이 될 수 없다.
    * 자신이 선언되어 있는 영역 내에서 프로그램이 실행되는 시간 동안 항상 유효
- shadowing
    * 재선언할 때에도 `let` 키워드를 붙임
    * 이전에 선언한 변수와 같은 이름의 새 변수를 선언할 수 있음. 이때 새 변수는 이전 변수를 shadow함.
    * 몇 번 값을 바꿀 순 있지만 그 외에는 불변을 유지해야 할 때 사용


## 데이터 타입
> Rust는 타입이 고정된 언어로, 모든 변수의 타입이 컴파일 시에 반드시 정해져 있어야 한다.
- 대개 컴파일러는 타입을 추측하지만, parse 등 선택 폭이 넓다면 명시 필요
- **스칼라**: 하나의 값으로 표현되는 타입
    * 정수형
        + 8/16/32/64 비트의 양수만(u) 음수포함(i) 타입을 가짐 ex. `i32`
        + `isize`, `usize`: 컴퓨터 환경에 따라 64bit면 ?64, 32bit면 ?32를 갖게 해주는 타입
        + 기본 타입인 i32가 일반적으로 가장 빠르기 때문에 추천
    * 부동소수점 숫자
        + `f32`, `f64`
        + 기본 타입은 f64로, f32와 비슷한 속도를 내면서 더 정밀한 표현이 가능하기 때문
    * boolean
        + `true`, `false`
    * 문자
        + `str`은 큰따옴표, `char`은 작은따옴표 사용
        + string은 muttable, char는 immutable
- **컴파운드**: 다른 타입의 다양한 값들을 하나의 타입으로 묶음
    * 튜플화
        ```rust
        let tup: (i32, f64, u8) = (500, 6.4, 1);
        let (x, y, z) = tup; // 패턴 매칭
        let five_hundred = x.0; // 인덱싱
        ```
    * 배열
        ```rust
        let a = [1, 2, 3, 4, 5];
        let first = a[0]; // 인덱싱. 유효하지 않은 인덱스를 요청시 프로그램 즉시 종료
        ``` 
        + 요소들의 타입이 모두 같아야 하고, 고정 길이
        + 데이터를 heap보다 stack에 할당하는 것을 원하는 경우
        + cf. 가변적인 것은 벡터. 유사 집합체로 표준 라이브러리에서 제공.


## 함수 동작 원리
- 함수 선언은 `fn` 키워드를 붙여서 만든다.
- 함수 선언 위치는 무관함
- 함수의 매개변수는 타입을 명시해둬야 함
- Rust는 표현식 기반 언어
    * 구문(statement): 어떤 명령들의 나열로 값을 반환하지 않는 어떤 동작을 수행 
    * 표현식(expression): 결과 값을 산출 (함수 또한 표현식)
        + ex. x = 3 일 때, 3은 3을 리턴하는 표현식이고, y = foo(bar) 일 때 foo는 표현식이고, fn z() {} 에서 {} 또한 새로운 범위를 생성하는 표현식이다.
        + 표현식은 종결을 뜻하는 세미콜론을 쓰지 않는다. ex. {let x=3; x+1} 이면 4를 리턴하는 표현식.
- 함수의 반환 타입은 `->` 뒤에 명시 ex. `fn foo() -> i32 {}`
    * return 키워드로 값을 일찍 리턴할 수 있음
    * 대개는 마지막 줄의 표현식이 리턴값이 됨


## 주석
- `//` 를 붙인 뒤 주석 내용을 기입


## 제어문
- 조건문
    * if 식의 조건 부분은 `arm` 이라고 부름
    * 조건은 항상 bool 이어야 함
    * if 역시 표현식이라서 let 구문 뒤에 사용 가능 ex. `let foo = if cond {3} else {5};`
- 반복문
    * `loop`: 명시하기 전까지 끊임없이 반복
    * `while`: 조건을 만족하는 동안 끊임없이 반복
    * `for`: 콜렉션을 순회
        + 이 경우 while은 에러가 발생하기 쉽고, 컴파일러가 실행 간에 반복문을 통해 반복될 때마다 요소에 대한 조건 검사를 수행하는 런타임 코드를 추가하기 때문에 느리다.