# 소유권 이해하기
> 다른 언어에는 없는 Rust의 특성으로, 가비지 콜렉터 또는 수동 리소스 반환 없이 메모리 안정성 보장을 하게 함

## 소유권?
- 모든 프로그램은 실행하는 동안 컴퓨터의 메모리를 사용하는 방법을 관리해야 함
    * 1안: 더이상 사용하지 않는 메모리를 끊임없이 찾는 가비지 콜렉션
    * 2안: 프로그래머가 명시적으로 메모리를 할당하고 해제
    * new: **컴파일 타임에 컴파일러가 체크할 규칙들로 구성된 소유권 시스템**을 통해 메모리를 관리
- 런타임 비용 발생 X
- 스택과 힙
    * 스택: 조회가 빠름 & 포인터 저장
    * 힙: 가변 데이터 저장(힙 공간 할당) & 포인터 반환
    * 코드의 어느 부분이 힙의 어떤 데이터를 사용하는지 추적하는 것, 힙의 중복된 데이터의 양을 최소화하는 것, 그리고 힙 내에 사용하지 않는 데이터를 제거하여 공간이 모자라지 않게 하는 것은 모두 **소유권**과 관계된 문제들
-  소유권 규칙
    1. 러스트의 각각의 값은 해당값의 오너(owner)라고 불리우는 변수를 갖고 있다.
    2. 한번에 딱 하나의 오너만 존재할 수 있다.
    3. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped).
- 변수의 스코프
    * 스코프: 프로그램 내에서 아이템이 유효함을 표시하기 위한 범위
- 메모리와 할당
    - 변경 가능한 변수에 대해 컴파일 타임에 힙에서 메모리 공간 할당이 필요
        * 런타임에 운영체제로부터 메모리가 요청되어야 한다. (=> `String::from`을 호출)
        * String의 사용이 끝났을 때 운영체제에게 메모리를 반납할 방법이 필요하다. (=> 소속된 스코프 밖으로 나가면 자동으로 반납)
            + 러스트는 } 괄호가 닫힐때 자동적으로 drop을 호출 (like C++의 RAII)
    - 변수와 데이터가 상호작용하는 방법: **이동**(move)
        * 어떤 변수가 다른 변수에게 재할당되면 (ex. x = y) y는 x로 이동되어 이후 호출이 막힌다.
        * 메모리 손상의 원인이 되는 두번 해제 (double free) 오류를 막기 위해서다.
        * 즉 결코 자동으로 깊은 복사가 이루어지지 않는다.
    - 변수와 데이터가 상호작용하는 방법: **클론**
        * 깊은 복사
    - 스택에만 있는 데이터: **복사**
        * 컴파일 타임에 결정되어 있는 크기의 타입은 스택에 모두 저장되어 깊은 복사와 얕은 복사의 차이가 없다.
        * 러스트는 스택에 저장 가능한 타입에는 `Copy` 트레잇을 가지는데, 만일 어떤 타입이 `Copy` 트레잇을 갖고 있다면, 대입 과정 후에도 예전 변수를 계속 사용할 수 있다.
        * 단, 러스트는 만일 그 타입 혹은 그 타입이 가지고 있는 부분 중에서 `Drop` 트레잇을 구현한 것이 있다면 `Copy` 트레잇을 어노테이션 할 수 없게끔 한다.
- 함수에 인자로 어떤 변수를 넘겨주고 나면, 그 변수에 `Copy` 트레잇이 없는 한 더이상 유효하지 않게 된다.
- 함수의 리턴 값은 어딘가에 할당되며 더 이상 유효하지 않게 된다.


## 참조자(References)와 빌림(Borrowing)
> 참조자의 규칙
> 1. 둘 중 하나만 선택 가능하다: `하나의 가변 참조자` vs `임의 개수의 불변 참조자들`
> 2. 참조자는 항상 유효해야만 한다
- 만약 함수 인자와 함수 리턴값을 다음 라인에서도 계속 사용해야 한다면 매번 복잡하게 받아와야 한다. => **참조자**를 넘기자!
    * 엠퍼센드(&) 기호로 참조자 명시
    * 참조자는 어떤 값을 소유권을 넘기지 않고 참조할수 있도록 한다.
    * 참조한 값은 변경할 수 없다. 기본적으로 참조자 역시 불변이다.
    * ex. `let len = calculate_length(&s1);` `fn calculate_length(s: &String) -> usize {...}`
- 함수의 인자로 참조자를 만드는 것을 **빌림**이라고 부른다.
    * 빌린 값은 다음 move를 위해 리턴할 필요가 없고, drop할 필요도 없다.
- 가변 참조자
    * &mut 과 같이 가변임을 명시
    * 단, 특정한 스코프 내에 특정한 데이터 조각에 대한 가변 참조자를 **딱 하나**만 만들 수 있다.
        ```rust
        let mut s = String::from("hello");

        let r1 = &mut s;
        let r2 = &mut s; // 여기에서 실패
        ```
        + 왜 이런 제한이 있는가? 컴파일 타임에 **데이터 레이스**를 방지하기 위해
        + 데이터 레이스? 아래 세 가지 동작이 발생했을때 나타나는 특정한 레이스 조건
            1. 두 개 이상의 포인터가 동시에 같은 데이터에 접근한다.
            2. 그 중 적어도 하나의 포인터가 데이터를 쓴다.
            3. 데이터에 접근하는데 동기화를 하는 어떠한 메커니즘도 없다.
    * 특이사항
        ```rust
        // ============== (1) ============== //
        let mut s = String::from("hello");
        {
            let r1 = &mut s;
        } // 여기서 r1은 스코프 밖으로 벗어남.

        let r2 = &mut s;
        // 그래서 이렇게 아무 문제 없이 새로운 참조자를 만들 수 있음.

        // ============== (2) ============== //
        let mut s = String::from("hello");

        let r1 = &s; // 문제 없음
        let r2 = &s; // 문제 없음
        let r3 = &mut s; // 문제: 불변 참조자를 갖고 있는 동안에도 가변 참조자 만들 수 없음.
        ``` 
- 댕글링 참조자
    * 포인터가 있는 언어에서는 댕글링 포인터를 만들기 쉽지만, 러스트는 이를 방지한다.
    * 댕글링 포인터? 어떤 메모리를 가리키는 포인터가 있는데, 그 메모리가 할당이 해제되어 다른 개체에게 재할당했을지도 모르는 상태인 것. (= 무효화된 포인터)


## 슬라이스
- 컬렉션 전체가 아닌 컬렉션의 연속된 일련의 요소들을 참조할 수 있게 해주는 소유권을 갖지 않는 데이터 타입
- start..end 문법 사용
    ```rust
    let s = String::from("hello world");
    let hello = &s[0..5];
    ```
    * start가 0이면 생략 가능
    * 맨 끝까지를 슬라이스하려고 한다면 end 생략 가능
- 슬라이스는 참조자이므로, 러스트는 원본 값을 삭제하려고 할 때 참조자가 있으면 컴파일 에러를 낸다.
    * 빌림 규칙에서 나왔듯, 뭔가에 대해 불변 참조자(ex. 슬라이스)가 있으면 가변 참조자(ex. 값 삭제를 위해 만드는 참조자)를 만들 수 없기 때문
- 스트링 리터럴은 바이너리의 특정 지점을 가리키고 있는 슬라이스로, &str 타입이다. 불변 참조자인 것.
- 스트링 외의 타입들도 슬라이스를 가질 수 있다.