# 일반적인 컬렉션
- 표준 라이브러리에는 컬렉션이라 불리는 여러 데이터 구조들이 포함되어 있다.
- 컬렉션은 다수의 값을 담을 수 있다.
- 빌드인 배열/튜플 타입과는 달리, 컬렉션들이 가리키는 데이터들은 힙에 저장된다.
    * 데이터량이 컴파일 타임에 결정되지 않아도 된다.
    * 프로그램이 실행될 때 늘어나거나 줄어들 수 있다.


## 벡터
> 여러 개의 값을 서로 붙어 있게 저장할 수 있게 함
- `Vec<T>`
- 메모리 상에 서로 이웃하도록 모든 값을 집어넣는 단일 데이터 구조 안에 다수의 값을 저장
- 같은 타입의 값만을 저장할 수 있음
- 편의를 위해 vec! 매크로를 지원: `let v = vec![1, 2, 3];`
- 값 추가: `v.push(5);`
- 값 해제: 스코프 밖으로 벗어나면 해제됨
- 값 접근
    * 인덱스 문법(`let third: &i32 = &v[2];`): 최대 인덱스 이상으로 접근하면 panic!을 일으킴
    * get 메소드(`let third: Option<&i32> = v.get(2);`): 최대 인덱스 이상으로 접근하면 None 리턴
- 같은 스코프 안에서 가변 참조자와 불변 참조자를 가질 수 없다. 첫번째 인덱스 값을 할당(불변참조자 생성)한 후 `push()`(과정에서 가변참조자 생성)할 수 없는 이유다.
- `for i in &v {}` 과 같이 for 루프로 각 요소의 불변/가변 참조자를 얻어 순회할 수 있다.
- 열거형 안의 요소 각각이 다른 타입을 가질 수 있기 때문에 벡터 안에 열거형을 사용하여 여러 타입의 값을 저장할 수 있다.


## 스트링
> 문자(character)의 모음
- 러스트 스트링의 특징
    * 가능한 에러를 꼭 노출하도록 하는 러스트의 성향
    * 많은 프로그래머의 예상보다 더 복잡한 데이터 구조인 스트링
    * UTF-8
- 러스트의 표준 라이브러리를 통해 제공
- 커질 수 있고, 가변적이며, 소유권을 갖고 있고, UTF-8로 인코딩된 스트링 타입
- concatenation: `push_str()`, `push()`, `+`, `format!(매크로)`
- 인덱싱 불가: 러스트가 스트링 내에 얼마나 많은 유효 문자가 있는지 알아내기 위해 내용물의 시작 지점부터 인덱스로 지정된 곳까지 훑어야 하기 때문에 이 연산이 O(1)에 실행될 수 없기 때문에
- 개별 유니코드 스칼라 값 또는 바이트 값에 for 문으로 접근 가능


## 해쉬맵
> 어떤 값을 특정한 키와 연관지음. Map의 구현.
- `HashMap<K, V>` 타입은 K 타입의 키에 V 타입의 값을 매핑한 것을 저장함
- 매핑은 해쉬 함수로 동작함. 해쉬 함수는 이 키와 값을 메모리 어디에 저장할지 결정함.
- 인덱스 대신 키로 값에 접근하길 원할 때 사용
- 어떤 변수가 키, 값으로서 해쉬맵에 `insert`되면 해쉬맵 소유가 되어 유효하지 않게 됨
- `get()`으로 값에 접근할 수 있음
- 값을 덮어쓰거나(`insert`), 없으면 생성(`entry`->`or_insert`)할 수 있음
- 성능을 위해 다른 hasher를 특정하여 해쉬 함수 변경 가능