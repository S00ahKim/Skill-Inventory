# 함수형 언어의 특성
> ex. 함수를 값처럼 인자로 넘기는 것, 다른 함수들에서 결괏값으로 함수들을 돌려주는 것, 나중에 실행하기 위해 함수를 변수에 할당하는 것 등


## 클로저
- 변수에 저장하거나 다른 함수에 인자로 넘길 수 있는 익명 함수
- 함수와 다르게 클로저는 그들이 호출되는 스코프로부터 변수들을 캡처할 수 있음
    * 클로저가 환경에서 값을 캡처할 때에는 캡처값을 저장할 메모리를 사용함
- `let expensive_closure = |num| {...}`와 같이 사용하는 파라미터를 | 안에 기술
    * 클로저의 파라미터나 반환값의 타입 명시는 필수가 아니지만, 명시적으로 표기 가능
    * 컴파일러가 문맥 안에서 타입을 추론
- 트레잇을 사용하여 클로저 저장
    * 표준 라이브러리는 Fn, FnMut, FnOnce 트레잇을 제공하고, 모든 클로저는 이 트레잇 중 하나를 구현한다.
    * 제네릭 파라미터와 Fn 트레잇을 사용해서 클로저를 구조체 필드에 넣을 수 있다.
- 클로저가 캡처하는 세 가지 방식
    1. 소유권 받기 (`FnOnce`)
    2. 불변으로 빌려오기 (`Fn`)
    3. 가변으로 빌려오기 (`FnMut`)
- 반복자: 표준 라이브러리에 정의된 `Iterator` 라는 이름의 트레잇을 구현
    * 지연(lazy) 특성: 반복자를 실제로 사용하는 메서드를 호출하기 전까지는 아무런 일도 일어나지 않는다.
    * `next` 메서드 구현 필요: 반복자의 하나의 항목을 `Some` 에 넣어서 반환 & 반복자가 종료되면 `None` 을 반환
    * next 를 호출하는 메서드들을 `소비하는 어댑터들`이라고 하는데, 그들을 호출하면 반복자를 써버리기 때문
    * 반복자는 러스트의 무비용 추상화(zero-cost abstractions) 기능중 하나. 런타임 오버헤드가 발생하지 않음.
        + [자바/파이썬은 반복자를 사용하면 힙에 데이터가 올라가는데, 러스트는 아니다.](https://ruudvanasseldonk.com/2016/11/30/zero-cost-abstractions)
        + [C#과 자바는 이터레이터의 성능이 더 좋지 않다](https://github.com/mike-barber/rust-zero-cost-abstractions/blob/main/README.md)