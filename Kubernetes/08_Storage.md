# 스토리지
- for 데이터 영속성
- 데이터 저장 및 참조하는 여러 방법 제공
- 매커니즘 구조
    * 데이터 저장소 제공 (프로비저닝)
        + PersistentVolume: 클러스터 관리자의 데이터 제공을 지원하는 리소스
        + StorageClass: 클러스터 관리자가 사용자들에게 제공하는 저장소 종류. 동적으로 저장소 제공을 지원
    * 마련한 저장소 사용
        + PersistentVolumeClaim: 일반 사용자가 데이터 저장소를 활용하는 것을 지원하는 리소스
- 왜 저런 구조?
    * 생명주기를 나누어 관리하여 플랫폼 종속성을 낮추기 위해
    * 파드의 생명주기와 무관하게 인프라적 성격을 띠고 유지되며 비용이 발생하는 Node, 그때그때 생성되고 삭제되며 노드의 리소스를 소모하는 Pod
    * 유사하게, PVC의 생명주기와 무관하게 인프라적 성격을 띠고 유지되며 비용이 발생하는 PV, 사용자 요청에 따라 생성/삭제되며 PV를 사용하는 PVC


## PersistentVolume
- 클러스터 레벨
- 데이터 저장소를 추상화한 리소스
- 구체적인 저장소 정보가 담김
    * 저장소 크기 capacity
    * 몇 개의 파드에서 볼륨에 접근할 수 있는지 accessModes
    * etc.
- PV 종류
    * hostPath PV (호스트 서버의 볼륨 연결)
    * NFS PV (네트워크 파일 시스템 서버의 볼륨 연결)
    * awsElasticBlockStore PV (AWS, EC2의 하드디스크(SSD))
    * 그 외에도 다양한 PV가 지원됨. PersistentDisk(@GCP) etc.
- 상태
    * `kubectl describe persistentvolume <name>` 
    * Available 볼륨만 생성되고 실제로 데이터 저장소를 사용하는 쪽은 없음
    * Bound 볼륨이 클레임에 바인딩됨
    * Released 클레임이 삭제되었지만 클러스터에서 아직 리소스를 반환하지 않음
    * Failed 볼륨이 자동 반환에 실패함


## PersistentVolumeClaim
- 네임스페이스 레벨
- 사용자가 PV를 요청하는 리소스, PV의 사용을 요청하는 역할
- PVC 리소스 정의서에 선점할 PV 이름 등을 지정해서 PVC를 생성하면 이게 PV를 연결해줌
- 저장소 연결 순서
    1. 클러스터 관리자가 PV 생성
    2. PV 정의에 따라 구체적인 볼륨 생성
    3. 일반 사용자가 PVC를 생성하여 PV 선점 요청
    4. PV와 연결되어 볼륨을 사용할 수 있게 됨
- PVC 생성 후 PV를 조회하면 status가 Bound로 변경되어 있음 & CLAIM에 PVC 이름이 노출됨
- 데이터 저장소를 사용자가 날리기 전까지 파드가 삭제되는 것과 무관하게 데이터는 영속적으로 유지됨


## StorageClass
- 클러스터 레벨
- 사용자는 관리자가 제공하는 StorageClass를 이용하여 동적으로 볼륨을 제공받을 수 있음
    * [일반적인 상황] 가용한 볼륨이 없다면 파드가 생성되지 않고 Pending으로 대기함
    * [StorageClass를 사용하는 상황] 볼륨 생성을 기다리지 않고 동적으로 저장소를 제공받음
- 역할 자체는 볼륨을 만드는 PV와 같지만, 그 외에 StorageClass를 사용하는 이유가 있다
    1. 특정 위치를 강제하여 PV를 마운트한다 (사용자가 아무 위치에나 만들지 않게 함)
    2. 복잡한 인프라 정보를 알아야 하는 PV의 경우 사용자가 그걸 알 필요 없이 StorageClass에 위임한다 (쉽게 사용 가능)

