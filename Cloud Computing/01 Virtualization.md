# 가상화 기술

## 개념
- 가상화 기술? 서버의 리소스 가상화로 `하나의 서버에 여러 대의 OS를 동작`시킬 수 있는 기술
- 특징?
   * 장점: 코어가 놀지 않고 최대한으로 서버의 사용 효율(Utilization)을 얻을 수 있다.
   * 단점: 개별 VM은 느려질 수 있다 
   * CPU의 기능 지원이 필요하다. 일부는 지원하지 않는다. 


## 용어
- 리소스 가상화 (가상화된 운영 환경에는 `가상 머신`과 `컨테이너` 두 가지가 있다)
   * **가상 머신 (VM)**
     + 하이퍼바이저(=클라우드를 구축하기 위한 가능 기술)로 하드웨어 스택 전체를 가상화하여 가상 머신으로 제공
     + 컴퓨터 자원 (CPU 메모리 저장장치 네트워크 등)을 추상화하고 프로비저닝(사용 가능한 상태로 준비) 
   * **컨테이너**
     + 운영체제 레벨에서 프로세스를 컨테이너 형태로 격리하여 제공
- 하이퍼바이저
   * 호스트 시스템에서 다수의 게스트 OS를 돌리기 위한 플랫폼 
- 호스트 OS
   * 물리시스템(컴퓨터) 위의 OS 
- 게스트 OS
   * 가상머신, 컨테이너 위의 OS


## 가상화 레벨
> 무엇과 무엇이 커뮤니케이션할 때 적용되는가

-	**API** (Application Programming Interface)
  1. 애플리케이션 레벨의 함수/메소드
  2. 커뮤니케이션: SW 컴포넌트 <-> SW 컴포넌트
  3. 리눅스에서 윈도를 돌리는 경우 지금처럼 Virtual Box 같은 걸 깔 수 있지만, 그냥 커널에 다른 쉘을 붙여도 된다. OS는 일반적으로 커널과 쉘로 나뉜다. 핵심은 커널로, 프로세스, 쓰레드 관리, 메모리 매니지먼트, 파일 IO, 네트워크 IO 관리를 담당한다. 쉘은 유저 인터페이스로, 그냥 껍데기다. 그리고 API는 이 쉘에서 사용된다. C의 malloc, new, free, delete, finallize() 같은 API를 콜하면, 실제 메모리관리는 커널에있어서 커널모드로 스위칭한 다음에 언더스코어 계열 함수 (시스템 콜)로 전환되어 돌아가게 된다. ex. WSL1(Windows Subsystem for Linux 1) / WineHQ

- **ABI** (Application Binary Interface)
1. 플랫폼과 소프트웨어 사이의 인터페이스 정의 
2. 커뮤니케이션: 애플리케이션 <-> OS/하드웨어
3. API보다 낮은 레벨. API는 유지되는데 ABI가 변경되어 코드는 유지한 채 재컴파일하는 경우가 있다. 예를 들어 똑같이 윈32를 쓰는데, x86에서는 잘되는데, ARM에서 돌리면 씨피유 구조가 달라서 (칩에 의존적인 부분이 있어서) 재컴파일이 필요해지는 것. ex. x86 Android(블루스택 - intel CPU + Android) / WindowsRT

- **ISA** (Instruction Set Architecture)
1. 하드웨어와 소프트웨어 사이의 인터페이스 정의
2. 커뮤니케이션: SW 컴포넌트 <-> 하드웨어
3. 대부분의 가상화에 해당한다. ex. 바이오스, 어셈블리


## 종류
### 호스트 가상화
Base가 되는 Host OS위에 Guest OS가 구동되는 방식. 가상의 하드웨어를 에뮬레이팅하기 때문에 호스트 운영체제에 크게 제약사항이 없다. 하지만 OS위에 OS가 얹히는 방식이기 때문에 오버헤드가 크다. 하이퍼바이저 가상화는 호스트 가상화에서 가상화 소프트웨어 + 게스트 OS를 그냥 하이퍼바이저로 대체한 것이다.

### 하이퍼바이저 가상화
- 특징
   * 시스템 가상화로 `다양한 게스트 OS`를 실행할 수 있다.
   * `성능 저하`: 느려지는 이유는 가상화가 결국 **번역**의 개념이라서 **오버헤드**(10-15%)가 있기 때문이다. 그리고 게스트 OS가 하드 위에서 도는지 하이퍼바이저 위에서 도는지 구분을 못할 경우, 스케줄링을 할 때 게스트 OS 쪽에서 하드웨어와 소프트웨어 제어를 둘 다 하려고 해서 **업무 영역 충돌**이 생기게 된다. (= 기능 중복이 있어서 프로세스 스케줄링을 할 때 쓸데없는 짓 하느라 시간 씀)
   * 대량 서버에 배치(deployment)하기 어려움
2.	종류
   * **VMWare**: 대표적인 상용 하이퍼바이저. 유명한 것은 vSphere이다. ESXi와 VCenter로 이루어져 있는데, 각각 도커와 쿠버네티스에 대응됨
   * MS Hyper-V: 윈도우서버에 통합
   * Ctrix Xen(오픈소스): 최초의 반가상화 하이퍼바이저
   * KVM(오픈소스): 하이퍼바이저를 커널의 ‘서브모듈'로 제공 (.ko) 메모리관리자/파일시스템/하이퍼바이저
   * 패러렐즈(Parallels): OSX기반의 하이퍼바이저
   * 오라클 버추얼박스(Oracle VirtualBox): 오라클에서 만든 GPL기반의 하이퍼바이저. 설치할 때 에러가 발생한다면 CPU 지원 여부, 바이오스 설정, 다른 하이퍼바이저들과 충돌이 났는지 등을 확인
3. 하이퍼바이저의 **위치와 역할**에 따른 분류
   * ![cc_01_01](../images/cc_01_01.png)
   * Type 1: 하이퍼바이저가 하드웨어 위에서 바로 실행됨. 리눅스 커널에 하이퍼바이저를 통합하는 방식. 상대적으로 가볍다. VMWare ESXi 방식.
   * Type 2: 호스트 OS 위에서 하이퍼바이저를 실행. 기본. 워크스테이션, 퓨젼.
4. 하이퍼바이저의 가상화 방식에 따른 분류
   * `전가상화` (Full Virtualization)
      - 하드웨어를 완전히 가상화
      - OS의 제약없이 사용할 수 있음
      - 게스트OS는 자신이 가상머신 위에서 동작하고 있다는 것 **인식불가**
      - 시스템에서 물리적인 가상화 지원기능 필요 (인텔 VT-x, AMD-V)
      - **게스트OS에서 물리자원 직접 접근 불가**
      - 반드시 **하이퍼바이저**를 통해서 접근해야 함-> 성능저하
   * `반가상화` (Para Virtualization)
      - 게스트OS가 자신이 가상머신 위에서 동작하고 있다는 것을 인식
      - OS 제약이 있음. 커널을 수정해야 함 (주로 오픈소스인 리눅스만 됨)
      - **게스트OS에서 물리자원 직접 접근 가능(Passthrough)** -> 성능개선
   * **컨테이너 기반 가상화 (ex. `Docker`)**
      - 개념: 하드웨어가 아니라 **실행 환경을 분리**하여 컨테이너 간 영향 분리
      - 특징
        * Docker의 전반적인 특징? 가볍고, 스마트하다!
        * 구축과 실행이 단순하다. (Build -> Ship -> Run)
        * 실행 프로세스가 컴팩트하다. 도커 이미지는 도커 이미지는 내용에 비해 크기가 아주 작은데, 이유는 커널이 다 같아서 나머지 부분만 받아오는 거라서다.
        * 가상화 최대 단점은 느려지는 것이다. Docker의 오버헤드는 기존 10% 대에서 3% 대로 내려가 성능이 좋다.
        * DockerHub로 회사와 개인이 구축한 이미지를 공유한다.
        * Docker 기반 기술 활성화 (에코시스템) ex. 도커컴포즈, 스웜 등
      - 기술적인 특징
        * 모든 컨테이너가 **동일한 OS 커널을 공유**한다.
        * 독립적인 스케줄링 X 하드웨어 가상화 X
        * 리눅스 특수기능인 LXC(리눅스 컨테이너)로 실행환경을 격리하므로, **리눅스에서만 사용 가능**하다.
            + LXC: CPU, 메모리, 디스크, 네트워크를 제어하는 `cgroups`, 프로세스트리, 사용자계정, 파일시스템, IPC를 제어하여 호스트와 별개의 공간을 설정할 수 있도록 돕는 `namespaces` (namespaces isolation) 기능을 제공
            + 다른 OS에서 사용하려면 일반 경량 하이퍼바이저가 필요
        * OS 의존성을 개선하려는 시도
            + 1차: `LXC`(ubuntu에서만 사용 가능, 시스템 레벨 가상화 지원)
            + 2차: `Libcontainer`(리눅스 배포판에서 범용으로 사용 가능하도록 도입된 실행 드라이버)
            + 3차: `RunC` (CNCF에서 만드는 OCI(Open Container Initiative) 컨테이너 기술 표준 준수. 최신 방식인 `containerd`는 컨테이너를 실행하고 노드에서 이미지를 관리하는 데 필요한 최소한의 기능 세트를 제공하는 OCI 호환 코어 컨테이너 런타임 중 하나이며, 컨테이너 관리를 위해 runC를 사용함)
        * cf. 사용자가 docker run 을 통해 container 기동을 요청시 처리 과정 [출처](http://cloudrain21.com/examination-of-docker-process-binary)
            1. dockerd 는 요청을 gRPC 를 통해 containerd 로 전달한다.
            2. containerd 는 exec 을 통해 containerd-shim 을 자식으로 생성한다.
            3. containerd-shim 은 runc 를 이용하여 container 를 생성한다.(runc 는 container 가 정상적으로 실행되면 exit 한다.)
            4. containerd-shim 은 그대로 살아있으며, 이는 container 내에서 실행되는 process 들의 부모가 된다. 
      - 한계
        * 보안: Docker는 실행할 때 루트 사용자 권한(sudo)을 요구한다.
            + `도커는 containerd가 제어하는 구조`로, containerd가 부모 프로세스, runC가 자식 프로세스가 되어 containerd에 문제가 생기면 runC에까지 영향을 미칠 수 있는 잠재적 취약점이 있다.
            + 반면 Redhat 계열에서 제공하는 `podman은 커널에서 개별 컨테이너를 독립적으로 실행하는 구조`로 되어 있다. 커널에 직접 이미지가 올라가고 위에 컨테이너가 동작하는 구조이기 때문에 컨테이너의 독립적 실행이 가능하며, 시스템 데몬 등록을 통해서 컨테이너별 실행 및 중단이 가능하다.
            + 그 외에 우분투를 만든 캐노니컬에서 만든 컨테이너 솔루션인 LXD는 LXC에 보안 개념을 추가하여 루트가 아니라도 컨테이너를 만들 수 있게 되었다. 도커는 Application Container라면, LXD는 Machine Container로, 컨테이너 하이퍼바이저라고 할 수 있다. 경쟁기술이라기보다 보완 관계로, 도커와 병행할 수 있다. KVM(Kernel Virtual Machine)을 경쟁기술로 간주한다.
        * 서버 실행 실황을 관리하는 리눅스 서비스와 충돌
            + 환경변수 실행방법이 다른 것도 프로세스 생성하는 service와 충돌하기 때문. 실제 서버를 실행하는 방법도 service 스크립트가 아닌 직접 해당 서버 실행하는 방식을 사용하기도. (ex. `service apache2 start` vs. `apachectl -D FOREGROUND`)
      - 이미지 생성
        * `docker commit` 컨테이너에 접속해서 직접 설치하고 설정해서 커밋하는 방법
        * `docker build` 도커파일을 생성하고 그걸 실행시켜서 이미지를 만드는 방법
      - Dockerfile
        * `FROM`
            + 도커 이미지 생성할 때 사용할 기본 이미지를 지정
            + 만약 해당 이미지가 없으면 서버 저장소(repository)에서 다운로드 받는다. 
        * `MAINTAINER` : 이미지를 생성한 사람에 대한 기본 정보표시
        * `RUN` : FROM에서 지정한 기본 이미지 위에 명령 수행해 새로운 이미지 생성
        * `CMD`
            + 컨테이너가 수행될 때 지정된 명령어/명령/스크립트 파일 실행
            + Dockerfile에서 한 번만 가능
            + `CMD [“echo $PATH”]`
        * `ENTRYPOINT`
            + CMD와 거의 같으나 컨테이너 생성(run)이나 시작(start)될 때 실행
            + `ENTRYPOINT [“/sample.sh”]`
        * `ADD`
            + 호스트의 특정 파일을 이미지 생성시 컨테이너의 /에 추가(복사)
            + 압축파일을 지정할 경우 압축을 풀어 추가
            + URL을 지정할 경우에는 압축해제 없이 추가됨
            + `ADD ~/sample.txt /sample.txt`
        * `USER` : RUN/CMD/ENTRYPOINT 수행하기 전, 사용자 계정을 지정.
        * `WORKDIR` : RUN/CMD/ENTRYPOINT 수행하기 전 수행할 디렉토리를 지정.
      - 영속적 파일 저장
        * 컨테이너에 쓰여진 데이터는 기본적으로 컨테이너가 삭제될 때 함께 사라진다.
        * 컨테이너가 사라져도 데이터를 남기기 위해 데이터를 컨테이너가 아닌 **호스트에 저장**하는 방식
        * `volume`
            + 컨테이너의 폴더와 호스트의 물리 폴더 연결
            + 볼륨을 생성 -> **컨테이너에 마운트**
            + 같은 볼륨을 다른 컨테이너의 경로에 마운트할 수 있음 (컨테이너간 데이터 공유 가능)
        * `bind mount`
            + 호스트 파일 시스템의 특정 경로를 컨테이너로 **바로** 마운트
            + 마운트 포인트를 도커가 관리함 (볼륨은 사용자가 알아서 생성/관리해야 하지만, 바인드 마운트는 도커 상에서 이미지/컨테이너/네트워크처럼 관리됨)
      - 멀티 컨테이너 관리: **Docker Compose**
        * 컨테이너를 하나씩 실행하지 않고, 한번에 실행시킬 수 있게 하는 기술
        * YAML 파일을 사용하여 애플리케이션의 서비스를 구성
        * 배포 환경을 구성하는 것이 복잡해서 (코드 변경 실시간으로, 컨테이너 순차적 배포 및 재실행 등) 도입
        * [44bits - 도커 컴포즈로 장고 개발환경 구축](https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose)
        * [다나와 - 도커 컴포즈 예제](https://danawalab.github.io/docker/2021/01/13/docker-compose-guideline.html) 